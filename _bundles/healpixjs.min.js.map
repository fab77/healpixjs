{"version":3,"file":"healpixjs.min.js","mappings":"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","sources":["webpack://healpixjs/webpack/universalModuleDefinition","webpack://healpixjs/webpack/bootstrap","webpack://healpixjs/webpack/runtime/define property getters","webpack://healpixjs/webpack/runtime/hasOwnProperty shorthand","webpack://healpixjs/webpack/runtime/make namespace object","webpack://healpixjs/./src/Constants.ts","webpack://healpixjs/./src/pstack.ts","webpack://healpixjs/./src/Pointing.ts","webpack://healpixjs/./src/Zphi.ts","webpack://healpixjs/./src/Hploc.ts","webpack://healpixjs/./src/Vec3.ts","webpack://healpixjs/./src/CircleFinder.ts","webpack://healpixjs/./src/Fxyf.ts","webpack://healpixjs/./src/RangeSet.ts","webpack://healpixjs/./src/Xyf.ts","webpack://healpixjs/./src/Healpix.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"healpixjs\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"healpixjs\"] = factory();\n\telse\n\t\troot[\"healpixjs\"] = factory();\n})(self, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","\n\nexport class Constants{\n  \n  \n//\tstatic halfpi = Math.PI/2.;\n\tstatic halfpi = 1.5707963267948966;\n\t\n\n\tstatic inv_halfpi = 2./Math.PI;\n\t\n\t  /** The Constant twopi. */\n\tstatic twopi = 2*Math.PI;\n\tstatic inv_twopi = 1./(2*Math.PI);\n\n}\n\n","export class pstack{\n\t\n\tp: number[];\n\to: Int32Array;\n\ts: number;\n\tm: number;\n\t\n\t/** Creation from individual components */\n\tconstructor(sz: number){\n    \tthis.p = new Array(sz); \n\t\tthis.o = new Int32Array(sz);\n\t\tthis.s = 0;\n\t\tthis.m = 0;\n\t};\n\t\n\t/**\n\t * @param p long\n\t * @param o int\n\t */\n\tpush (p_: number, o_: number){ \n\t\tthis.p[this.s]= p_; \n\t\tthis.o[this.s]= o_; \n\t\t++this.s;\n\t};\n\t\n  \tpop (){ \n  \t\t--this.s; \n  \t};\n  \n  \tpopToMark (){ \n  \t\tthis.s=this.m; \n  \t};\n  \n\tsize (){ \n\t\treturn this.s; \n\t};\n  \n\n\tmark (){ \n\t\tthis.m=this.s; \n\t};\n  \n\totop (){ \n\t\treturn this.o[this.s-1]; \n\t};\n  \n\tptop (){ \n\t\treturn this.p[this.s-1]; \n\t};\n\t\n}\n","import { Hploc } from './Hploc.js';\nimport { Vec3 } from './Vec3.js';\n\n\n\nexport class Pointing {\n\n\n\n\ttheta: number;\n\tphi: number;\n\n\t/**\n\t * \n\t * @param {*} vec3 Vec3.js\n\t * @param {*} mirror \n\t * @param {*} in_theta radians\n\t * @param {*} in_phi radians\n\t */\n\tconstructor(vec3: Vec3 | null, mirror?: boolean, in_theta?: number, in_phi?: number) {\n\n\t\tif (vec3 != null) {\n\t\t\tthis.theta = Hploc.atan2(Math.sqrt(vec3.x * vec3.x + vec3.y * vec3.y), vec3.z);\n\t\t\tif (mirror) {\n\t\t\t\tthis.phi = - Hploc.atan2(vec3.y, vec3.x);\n\t\t\t} else {\n\t\t\t\tthis.phi = Hploc.atan2(vec3.y, vec3.x);\n\t\t\t}\n\n\n\t\t\tif (this.phi < 0.0) {\n\t\t\t\tthis.phi = this.phi + 2 * Math.PI;\n\t\t\t}\n\t\t\tif (this.phi >= 2 * Math.PI) {\n\t\t\t\tthis.phi = this.phi - 2 * Math.PI;\n\t\t\t}\n\n\t\t} else {\n\t\t\tthis.theta = in_theta;\n\t\t\tthis.phi = in_phi;\n\t\t}\n\n\t}\n}\n\n","\nexport class Zphi{\n\t\n\tz: number;\n\tphi: number;\n\t\n\t/** Creation from individual components */\n\tconstructor(z_: number, phi_: number){\n    \tthis.z = z_; \n\t\tthis.phi = phi_; \n\t};\n\t\n}","import { Pointing } from './Pointing.js';\nimport {Vec3} from './Vec3.js';\nimport {Zphi} from './Zphi.js';\n\nexport class Hploc{\n\tstatic PI4_A = 0.7853981554508209228515625;\n\tstatic PI4_B = 0.794662735614792836713604629039764404296875e-8;\n\tstatic PI4_C = 0.306161699786838294306516483068750264552437361480769e-16;\n\tstatic M_1_PI = 0.3183098861837906715377675267450287;\n\t\n\tsth: number;\n\thave_sth: boolean;\n\tz: number;\n\t_phi: number;\n\n\n\tconstructor(ptg?: Pointing){\n\t\tHploc.PI4_A = 0.7853981554508209228515625;\n\t\tHploc.PI4_B = 0.794662735614792836713604629039764404296875e-8;\n\t\tHploc.PI4_C = 0.306161699786838294306516483068750264552437361480769e-16;\n\t\tHploc.M_1_PI = 0.3183098861837906715377675267450287;\n\t\tif ( ptg ){\n\t\t\tthis.sth = 0.0;\n\t\t\tthis.have_sth=false;\n\t\t\tthis.z = Hploc.cos(ptg.theta);\n\t\t\tthis._phi = ptg.phi;\n\t\t\tif (Math.abs(this.z)>0.99){\n\t\t\t\tthis.sth = Hploc.sin(ptg.theta);\n\t\t\t\tthis.have_sth=true;\n\t\t\t}\n\t\t}\n\t}\n\n\tsetZ(z: number){\n\t\tthis.z = z;\n\t};\n\t\n\tget phi(): number{\n\t\treturn this._phi;\n\t};\n\n\tset phi(phi: number){\n\t\tthis._phi = phi;\n\t};\n\n\tsetSth(sth: number){\n\t\tthis.sth = sth;\n\t};\n\t\n\t toPointing(mirror: boolean): Pointing {\n    \tconst st = this.have_sth ? this.sth : Math.sqrt((1.0-this.z)*(1.0+this.z));\n    \treturn new Pointing(null, false, Hploc.atan2(st,this.z), this._phi);\n    }\n\n\n\ttoVec3(): Vec3{\n\t\tvar st = this.have_sth ? this.sth : Math.sqrt((1.0-this.z)*(1.0+this.z));\n\t\tvar vector = new Vec3(st*Hploc.cos(this.phi),st*Hploc.sin(this.phi),this.z);\n\t\t// var vector = new Vec3(st*Math.cos(this.phi),st*Math.sin(this.phi),this.z);\n\t\treturn vector;\n\t};\n\n\ttoZphi(): Zphi { \n\t\treturn new Zphi(this.z, this.phi); \n\t}\n\n\t\n\tstatic sin(d: number): number{\n\t\t\n\t\tlet u = d * Hploc.M_1_PI;\n\t\tlet q = Math.floor(u < 0 ? u - 0.5 : u + 0.5);\n\t\tlet x = 4.0 * q;\n\t\td -= x * Hploc.PI4_A;\n\t\td -= x * Hploc.PI4_B;\n\t\td -= x * Hploc.PI4_C;\n\t\tif ((q & 1) != 0) {\n\t\t\td = -d;\n\t\t}\n\t\treturn this.sincoshelper(d);\n\t};\n\t\n\t\n\tstatic cos(d: number): number{\n\t\t\n//\t\tlet u = d * Hploc.M_1_PI - 0.5;\n\t\tlet u = d * Hploc.M_1_PI - 0.5;\n//\t\tu -= 0.5;\n\t\tlet q = 1 + 2 * Math.floor(u < 0 ? u - 0.5 : u + 0.5);\n\t\tlet x = 2.0 * q;\n\t\t\n\t\tlet t = x * Hploc.PI4_A;\n\t\td = d - t;\n\t\td -= x * Hploc.PI4_B;\n\t\td -= x * Hploc.PI4_C;\n\t\tif ((q & 2) == 0){\n\t\t\td = -d;\n\t\t}\n\t\treturn Hploc.sincoshelper(d);\n\t};\n\t\n\t\n\tstatic sincoshelper(d: number): number{\n\t\tlet s = d * d;\n\t\tlet u = -7.97255955009037868891952e-18;\n\t\tu = u * s +2.81009972710863200091251e-15;\n\t\tu = u * s -7.64712219118158833288484e-13;\n  \t\tu = u * s +1.60590430605664501629054e-10;\n  \t\tu = u * s -2.50521083763502045810755e-08;\n  \t\tu = u * s +2.75573192239198747630416e-06;\n  \t\tu = u * s -0.000198412698412696162806809;\n  \t\tu = u * s +0.00833333333333332974823815;\n  \t\tu = u * s -0.166666666666666657414808;\n\t\treturn s*u*d + d;\n\t};\n\t\n\t/** This method calculates the arc sine of x in radians. The return\n    value is in the range [-pi/2, pi/2]. The results may have\n    maximum error of 3 ulps. */\n\tstatic asin(d: number): number{ \n\t\treturn Hploc.mulsign(Hploc.atan2k(Math.abs(d), Math.sqrt((1+d)*(1-d))), d); \n\t};\n\t\n/** This method calculates the arc cosine of x in radians. The\n    return value is in the range [0, pi]. The results may have\n    maximum error of 3 ulps. */\n\tstatic acos(d: number): number {\n\t\treturn Hploc.mulsign(Hploc.atan2k(Math.sqrt((1+d)*(1-d)), Math.abs(d)), d) + (d<0 ? Math.PI : 0);\n\t};\n\t\n\tstatic mulsign(x: number, y: number): number{\n\t\tlet sign = Hploc.copySign(1, y);\n\t\treturn sign * x; \n\t};\n\t\n\tstatic copySign(magnitude: number, sign: number): number{\n\n\t\treturn sign < 0 ? -Math.abs(magnitude) : Math.abs(magnitude);\n\t\t// let finalsign = 1;\n\t\t// if (Object.is(finalsign , -0)){\n\t\t// \tsign = -1;\n\t\t// }else if (Object.is(finalsign , 0)){\n\t\t// \tsign = 1;\n\t\t// }else {\n\t\t// \tsign = Math.sign(finalsign);\n\t\t// }\n\t\t// return finalsign * magnitude;\n\t}\n\t\n\tstatic atanhelper(s: number): number{\n\t    let t = s * s;\n\t    let u = -1.88796008463073496563746e-05;\n\t    u = u * t + (0.000209850076645816976906797);\n\t    u = u * t + (-0.00110611831486672482563471);\n\t    u = u * t + (0.00370026744188713119232403);\n\t    u = u * t + (-0.00889896195887655491740809);\n\t    u = u * t + (0.016599329773529201970117);\n\t    u = u * t + (-0.0254517624932312641616861);\n\t    u = u * t + (0.0337852580001353069993897);\n\t    u = u * t + (-0.0407629191276836500001934);\n\t    u = u * t + (0.0466667150077840625632675);\n\t    u = u * t + (-0.0523674852303482457616113);\n\t    u = u * t + (0.0587666392926673580854313);\n\t    u = u * t + (-0.0666573579361080525984562);\n\t    u = u * t + (0.0769219538311769618355029);\n\t    u = u * t + (-0.090908995008245008229153);\n\t    u = u * t + (0.111111105648261418443745);\n\t    u = u * t + (-0.14285714266771329383765);\n\t    u = u * t + (0.199999999996591265594148);\n\t    u = u * t + (-0.333333333333311110369124);\n\t\n\t    return u * t * s + s;\n    };\n\n    static atan2k(y: number, x: number): number {\n\t    let q = 0.;\n\t\n\t    if (x < 0) { \n\t    \tx = -x; \n\t    \tq = -2.; \n\t    }\n\t    if (y > x) { \n\t    \tlet t = x; \n\t    \tx = y; \n\t    \ty = -t; \n\t    \tq += 1.; \n\t    }\n\t    return Hploc.atanhelper(y/x) + q*(Math.PI/2);\n    };\n\n /** This method calculates the arc tangent of y/x in radians, using\n the signs of the two arguments to determine the quadrant of the\n result. The results may have maximum error of 2 ulps. */\n\t static atan2(y: number, x: number): number {\n\t\t let r = Hploc.atan2k(Math.abs(y), x);\n\t\t\t\n\t\t r = Hploc.mulsign(r, x);\n\t\t if (Hploc.isinf(x) || x == 0){\n\t\t\t r = Math.PI/2 - (Hploc.isinf(x) ? (Hploc.copySign(1, x) * (Math.PI /2)) : 0);\n\t\t }\n\t      \n\t\t if (Hploc.isinf(y)){\n\t\t\t r = Math.PI/2 - (Hploc.isinf(x) ? (Hploc.copySign(1, x) * (Math.PI*1/4)) : 0);\n\t\t }\n\t\t\t      \n\t\t if (y == 0){\n\t\t\t r = (Hploc.copySign(1, x) == -1 ? Math.PI : 0);\n\t\t }\n\t\t return Hploc.isnan(x) || Hploc.isnan(y) ? NaN : Hploc.mulsign(r, y);\n\t };\n    \n\t /** Checks if the argument is a NaN or not. */\n\t static isnan(d: number): boolean {\n\t\t return d != d;\n\t };\n\n    /** Checks if the argument is either positive or negative infinity. */\n    static isinf(d:number): boolean{ \n    \treturn Math.abs(d) === +Infinity; \n    };\n\n\n}\n","/**\n * Partial porting to Javascript of Vec3.java from Healpix3.30  \n */\n\nimport {Hploc} from './Hploc.js';\nimport {Pointing} from './Pointing.js';\n\n\nexport class Vec3{\n\t\n\tx: number;\n\ty: number;\n\tz: number;\n\t\n\tconstructor(in_x: number | Pointing, in_y: number, in_z: number){\n\n\t\tif (in_x instanceof Pointing) {\n\t\t\tlet ptg = in_x;\n\t\t\tlet sth = Hploc.sin(ptg.theta);\n\t\t\tthis.x=sth*Hploc.cos(ptg.phi);\n\t\t\tthis.y=sth*Hploc.sin(ptg.phi);\n\t\t\tthis.z=Hploc.cos(ptg.theta);\n\t\t}else{\n\t\t\tthis.x = in_x;\n\t\t\tthis.y = in_y;\n\t\t\tthis.z = in_z;\n\t\t}\n\t\t\n\t}\n\tgetX(): number{\n\t\t  return this.x;\n\t};\n\t\t\n\tgetY(): number{\n\t  return this.y;\n\t};\n\t\n\tgetZ(): number{\n\t  return this.z;\n\t};\n\t\n\t/** Scale the vector by a given factor\n    @param n the scale factor */\n\tscale(n: number): void{\n\t\tthis.x *= n; \n\t\tthis.y*=n; \n\t\tthis.z*=n;\n\t};\n\t\n\t/** Vector cross product.\n    @param v another vector\n    @return the vector cross product between this vector and {@code v} */\n\tcross(v: Vec3): Vec3 {\n\t\treturn new Vec3(this.y*v.z - v.y*this.z, this.z*v.x - v.z*this.x, this.x*v.y - v.x*this.y);\n\t};\n\t\n\t/** Vector addition\n\t    * @param v the vector to be added\n\t    * @return addition result */\n\tadd(v: Vec3): Vec3 {\n\t\treturn new Vec3(this.x+v.x, this.y+v.y, this.z+v.z); \n\t};\n\t\n\t/** Normalize the vector */\n\tnormalize(): void{\n\t    let d = 1./this.length();\n\t    this.x *= d; \n\t    this.y *= d; \n\t    this.z *= d;\n\t};\n\t\n\t/** Return normalized vector */\n\tnorm(): Vec3 {\n\t\tlet d = 1./this.length();\n\t\treturn new Vec3(this.x*d, this.y*d, this.z*d);\n\t};\n\t  \n\t/** Vector length\n    @return the length of the vector. */\n\tlength(): number{ \n\t\treturn Math.sqrt(this.lengthSquared()); \n\t};\n\n  /** Squared vector length\n      @return the squared length of the vector. */\n\tlengthSquared(): number{ \n\t\treturn this.x*this.x + this.y*this.y + this.z*this.z; \n  \t};\n  \t\n  \t/** Computes the dot product of the this vector and {@code v1}.\n     * @param v1 another vector\n     * @return dot product */\n  \tdot(v1: Vec3): number {\n\t   return this.x*v1.x + this.y*v1.y + this.z*v1.z; \n   \t};\n   \t\n   \t/** Vector subtraction\n     * @param v the vector to be subtracted\n     * @return subtraction result */\n   \tsub(v: Vec3): Vec3 {\n   \t\treturn new Vec3(this.x-v.x, this.y-v.y, this.z-v.z); \n   \t};\n\t\n   \n   \t\n   \t/** Angle between two vectors.\n    @param v1 another vector\n    @return the angle in radians between this vector and {@code v1};\n      constrained to the range [0,PI]. */\n   \tangle(v1: Vec3): number { \n   \t\treturn Hploc.atan2(this.cross(v1).length(), this.dot(v1)); \n   \t}\n   \t\n   \t/** Invert the signs of all components */\n    flip(): void { \n    \tthis.x *= -1.0;\n    \tthis.y *= -1.0;\n    \tthis.z *= -1.0;\n    }\n   \t\n   \tstatic pointing2Vec3(pointing: Pointing): Vec3{\n   \t\tlet sth = Hploc.sin(pointing.theta);\n   \t    let x = sth * Hploc.cos(pointing.phi);\n   \t    let y = sth * Hploc.sin(pointing.phi);\n   \t    let z = Hploc.cos(pointing.theta);\n   \t    return new Vec3(x, y, z);\n   \t    \n   \t};\n} \n\n","\nimport {Vec3} from './Vec3.js';\n\n\nexport class CircleFinder{\n\t\n\tcenter;\t// Vec3\n\tcosrad;\t// double\n\t\n/**\n * @param point: Vec3\n */\n\tconstructor(point){\n\t\t\n\t\tlet np = point.length;\n\t    //HealpixUtils.check(np>=2,\"too few points\");\n\t    if (!(np>=2)){\n\t    \tconsole.log(\"too few points\");\n\t    \treturn;\n\t    }\n\t    this.center = point[0].add(point[1]); \n\t    this.center.normalize();\n\t    this.cosrad = point[0].dot(this.center);\n\t    for (let i=2; i<np; ++i){\n\t    \tif (point[i].dot(this.center)<this.cosrad){ // point outside the current circle\n\t\t        this.getCircle(point,i);\t\n\t    \t}\n\t    }\n\t      \n\t};\n\t\n\t/**\n\t * @parm point: Vec3\n\t * @param q: int\n\t */\n\tgetCircle (point, q){\n\t\tthis.center = point[0].add(point[q]); \n\t\tthis.center.normalize();\n\t\tthis.cosrad = point[0].dot(this.center);\n\t\tfor (let i=1; i<q; ++i){\n\t\t\tif (point[i].dot(this.center)<this.cosrad){ // point outside the current circle\n\t\t\t\tthis.getCircle2(point,i,q);\n\t\t\t}\n\t\t}\n    };\n\t\n\t/**\n\t * @parm point: Vec3\n\t * @param q1: int\n\t * @param q2: int\n\t */\n\tgetCircle2 (point, q1, q2){\n\t\tthis.center = point[q1].add(point[q2]); \n\t\tthis.center.normalize();\n\t\tthis.cosrad = point[q1].dot(this.center);\n\t\tfor (let i=0; i<q1; ++i){\n\t\t\tif (point[i].dot(this.center)<this.cosrad){// point outside the current circle\n\t        \n\t\t\t\tthis.center=(point[q1].sub(point[i])).cross(point[q2].sub(point[i]));\n\t\t\t\tthis.center.normalize();\n\t\t\t\tthis.cosrad=point[i].dot(this.center);\n\t\t\t\tif (this.cosrad<0){ \n\t\t\t\t\tthis.center.flip(); \n\t\t\t\t\tthis.cosrad=-this.cosrad; \n\t\t\t\t}\n\t        }\n\t\t}\n    };\n    \n    getCenter() { \n    \treturn new Vec3(this.center.x, this.center.y, this.center.z); \n    }\n    \n    getCosrad() { \n    \treturn this.cosrad; \n    };\n\t\n}\n\n","/**\n * Partial porting to Javascript of Fxyf.java from Healpix3.30\n */\n\nimport {Hploc} from './Hploc.js';\nimport {Vec3} from './Vec3.js';\n\nexport class Fxyf{ \n\t\n\tfx: number;\n\tfy: number;\n\tface: number;\n\tjrll: Uint8Array;\n\tjpll: Uint8Array;\n\thalfpi: number;\n\n\tconstructor(x: number, y: number, f: number){\n\t\tthis.fx=x; \n\t\tthis.fy=y; \n\t\tthis.face=f; \n\t\t// coordinate of the lowest corner of each face\n\t\tthis.jrll = new Uint8Array([ 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4 ]);\n\t\tthis.jpll = new Uint8Array([ 1, 3, 5, 7, 0, 2, 4, 6, 1, 3, 5, 7 ]);\n\t\tthis.halfpi = Math.PI/2.;\n\t}\n\n\ttoHploc(): Hploc{\t\n\t\tlet loc = new Hploc();\n\t\t\n\t\tlet jr = this.jrll[this.face] - this.fx - this.fy;\n\t\t\n\t\tlet nr: number;\n\t\n\t\tif (jr<1){\n\t\t\t  nr = jr;\n\t\t\t  let tmp = nr*nr/3.;\n\t\t\t  loc.z = 1 - tmp;\n\t\t\t  if (loc.z > 0.99) { \n\t\t\t\t  loc.sth = Math.sqrt(tmp*(2.0-tmp)); \n\t\t\t\t  loc.have_sth = true; \n\t\t\t  }\n\t\t}else if (jr > 3){\n\t\t\t  nr = 4 - jr;\n\t\t\t  let tmp = nr*nr/3.;\n\t\t\t  loc.z = tmp - 1;\n\t\t\t  if (loc.z <- 0.99) { \n\t\t\t\t  loc.sth = Math.sqrt(tmp*(2.0-tmp)); \n\t\t\t\t  loc.have_sth = true; \n\t\t\t  }\n\t\t}else{\n\t\t\t  nr = 1;\n\t\t\t  loc.z = (2 - jr)*2.0/3.;\n\t\t}\n\t\n\t\tlet tmp = this.jpll[this.face]*nr+this.fx-this.fy;\n\t\tif (tmp < 0) {\n\t\t\ttmp += 8;\n\t\t}\n\t\tif (tmp >= 8) {\n\t\t\ttmp -= 8;\n\t\t}\n\t\tloc.phi = (nr<1e-15) ? 0 : (0.5*this.halfpi*tmp)/nr;\n\t\treturn loc;\n\t};\n\t\n\t\n\ttoVec3(): Vec3{ \n\t\treturn this.toHploc().toVec3(); \n\t};\n}\n\n\n","export class RangeSet{\n\t\n\tr: Int32Array;\n\tsz: number;\n\t/**\n\t * @param int cap: initial capacity\n\t */\n\tconstructor(cap?: number){\n\t\tif (cap<0) console.error(\"capacity must be positive\");\n\t    this.r = new Int32Array(cap<<1);\n\t    this.sz=0;\n\t};\n\t\n\t\n\t/** Append a single-value range to the object.\n    @param val value to append */\n\tappend (val: number): void { \n\t\tthis.append1(val,val+1); \n\t};\n\t\n\t\n\t /** Append a range to the object.\n    @param a first long in range\n    @param b one-after-last long in range */\n\tappend1 (a: number, b: number): void {\n\t\tif (a>=b) return;\n\t\tif ((this.sz>0) && (a<=this.r[this.sz-1])) {\n\t\t\tif (a<this.r[this.sz-2]) console.error(\"bad append operation\");\n\t\t\tif (b>this.r[this.sz-1]) this.r[this.sz-1]=b;\n\t\t\treturn;\n\t\t}\n\t\t// this.ensureCapacity(this.sz+2);\n\t\tlet cap = this.sz+2;\n\t\tif (this.r.length < cap) {\n\t\t\tlet newsize = Math.max( 2 * this.r.length,cap);\n\t\t\tlet rnew = new Int32Array(newsize);\n\t\t\trnew.set(this.r);\n\t\t\tthis.r = rnew;\n\t\t}\n\t\t\n\t\tthis.r[this.sz] = a;\n\t\tthis.r[this.sz+1] = b;\n\t\tthis.sz+=2;\n\t};\n\t\n\t/** Make sure the object can hold at least the given number of entries. \n\t * @param cap int\n\t * */\n  \tensureCapacity(cap: number): void { \n  \t\tif (this.r.length < cap) \n  \t\t\tthis.resize (Math.max( 2 * this.r.length,cap)); \n  \t};\n\t\n\t/**\n\t * @param newsize int\n\t */\n\tresize(newsize: number): void {\n\t\tif (newsize<this.sz)  console.error(\"requested array size too small\");\n\t\tif (newsize == this.r.length) return;\n\t\tlet rnew = new Int32Array(newsize);\n\t\tlet sliced = this.r.slice(0, this.sz + 1);\n//\t\tthis.arrayCopy(this.r, 0, rnew, 0, this.sz);\n\t\tthis.r = sliced;\n    };\n\t\n//\tarrayCopy(src, srcIndex, dest, destIndex, length) {\n//\t\tdest.splice(destIndex, length, ...src.slice(srcIndex, srcIndex + length));\n//\t};\n\n  \n  \n}\n\n","/**\n * Partial porting to Javascript of Xyf.java from Healpix3.30  \n */\nexport class Xyf{\n\n\tix: number;\n\tiy: number;\n\tface: number;\n\n\tconstructor(x: number, y: number, f: number){\n\t\tthis.ix = x;\n\t\tthis.iy = y;\n\t\tthis.face = f;\n\t}\n}\n\n\n","\"use strict\";\r\n\r\nimport { CircleFinder } from \"./CircleFinder.js\";\r\nimport { Constants } from \"./Constants.js\";\r\nimport { Fxyf } from \"./Fxyf.js\";\r\nimport { Hploc } from \"./Hploc.js\";\r\nimport { Pointing } from \"./Pointing.js\";\r\nimport { pstack } from \"./pstack.js\";\r\nimport { RangeSet } from \"./RangeSet.js\";\r\nimport { Vec3 } from \"./Vec3.js\";\r\nimport { Xyf } from \"./Xyf.js\";\r\nimport { Zphi } from \"./Zphi.js\";\r\n\r\n/**\r\n * Partial porting to Javascript of HealpixBase.java from Healpix3.30\r\n */\r\n\r\n// import Fxyf from './Fxyf.js';\r\n// import Hploc from './Hploc.js';\r\n// import Xyf from './Xyf.js';\r\n// import Vec3 from './Vec3.js';\r\n// import Pointing from './Pointing.js';\r\n// import CircleFinder from './CircleFinder.js';\r\n// import Zphi from './Zphi.js';\r\n// import pstack from './pstack.js';\r\n// import Constants from './Constants.js';\r\n// import RangeSet from './RangeSet.js';\r\n\r\n\r\nexport class Healpix {\r\n\r\n    order_max: number;\r\n    inv_halfpi: number;\r\n    twothird: number;\r\n    ns_max: number;\r\n    ctab: Uint16Array;\r\n    utab: Uint16Array;\r\n    xoffset: Int16Array;\r\n    yoffset: Int16Array;\r\n\r\n    jrll: Int16Array;\r\n    jpll: Int16Array;\r\n\r\n    facearray: Int16Array[];\r\n    swaparray: Int16Array[];\r\n    nside: number;\r\n    npface: number;\r\n    npix: number;\r\n    order: number;\r\n    nl2: number;\r\n    nl3: number;\r\n    nl4: number;\r\n    fact2: number;\r\n    fact1: number;\r\n    ncap: number; // pixel\r\n    bn: Healpix[];\r\n    mpr: number[];\r\n    cmpr: number[];\r\n    smpr: number[];\r\n\r\n    constructor(nside_in: number) {\r\n        this.order_max = 29;\r\n        this.inv_halfpi = 2.0 / Math.PI;\r\n        this.twothird = 2.0 / 3.;\r\n        // console.log(\"twothird \"+this.twothird);\r\n        // this.ns_max=1L<<order_max;\r\n        this.ns_max = Math.pow(2, this.order_max);\r\n        this.ctab = new Uint16Array([\r\n            0, 1, 256, 257, 2, 3, 258, 259, 512, 513, 768, 769, 514, 515, 770, 771, 4, 5, 260, 261, 6, 7, 262,\r\n            263, 516, 517, 772, 773, 518, 519, 774, 775, 1024, 1025, 1280, 1281, 1026, 1027, 1282, 1283,\r\n            1536, 1537, 1792, 1793, 1538, 1539, 1794, 1795, 1028, 1029, 1284, 1285, 1030, 1031, 1286,\r\n            1287, 1540, 1541, 1796, 1797, 1542, 1543, 1798, 1799, 8, 9, 264, 265, 10, 11, 266, 267, 520,\r\n            521, 776, 777, 522, 523, 778, 779, 12, 13, 268, 269, 14, 15, 270, 271, 524, 525, 780, 781, 526,\r\n            527, 782, 783, 1032, 1033, 1288, 1289, 1034, 1035, 1290, 1291, 1544, 1545, 1800, 1801, 1546,\r\n            1547, 1802, 1803, 1036, 1037, 1292, 1293, 1038, 1039, 1294, 1295, 1548, 1549, 1804, 1805,\r\n            1550, 1551, 1806, 1807, 2048, 2049, 2304, 2305, 2050, 2051, 2306, 2307, 2560, 2561, 2816,\r\n            2817, 2562, 2563, 2818, 2819, 2052, 2053, 2308, 2309, 2054, 2055, 2310, 2311, 2564, 2565,\r\n            2820, 2821, 2566, 2567, 2822, 2823, 3072, 3073, 3328, 3329, 3074, 3075, 3330, 3331, 3584,\r\n            3585, 3840, 3841, 3586, 3587, 3842, 3843, 3076, 3077, 3332, 3333, 3078, 3079, 3334, 3335,\r\n            3588, 3589, 3844, 3845, 3590, 3591, 3846, 3847, 2056, 2057, 2312, 2313, 2058, 2059, 2314,\r\n            2315, 2568, 2569, 2824, 2825, 2570, 2571, 2826, 2827, 2060, 2061, 2316, 2317, 2062, 2063,\r\n            2318, 2319, 2572, 2573, 2828, 2829, 2574, 2575, 2830, 2831, 3080, 3081, 3336, 3337, 3082,\r\n            3083, 3338, 3339, 3592, 3593, 3848, 3849, 3594, 3595, 3850, 3851, 3084, 3085, 3340, 3341,\r\n            3086, 3087, 3342, 3343, 3596, 3597, 3852, 3853, 3598, 3599, 3854, 3855]);\r\n        this.utab = new Uint16Array([0, 1, 4, 5, 16, 17, 20, 21, 64, 65, 68, 69, 80, 81, 84, 85, 256, 257, 260, 261, 272, 273, 276, 277,\r\n            320, 321, 324, 325, 336, 337, 340, 341, 1024, 1025, 1028, 1029, 1040, 1041, 1044, 1045, 1088,\r\n            1089, 1092, 1093, 1104, 1105, 1108, 1109, 1280, 1281, 1284, 1285, 1296, 1297, 1300, 1301,\r\n            1344, 1345, 1348, 1349, 1360, 1361, 1364, 1365, 4096, 4097, 4100, 4101, 4112, 4113, 4116,\r\n            4117, 4160, 4161, 4164, 4165, 4176, 4177, 4180, 4181, 4352, 4353, 4356, 4357, 4368, 4369,\r\n            4372, 4373, 4416, 4417, 4420, 4421, 4432, 4433, 4436, 4437, 5120, 5121, 5124, 5125, 5136,\r\n            5137, 5140, 5141, 5184, 5185, 5188, 5189, 5200, 5201, 5204, 5205, 5376, 5377, 5380, 5381,\r\n            5392, 5393, 5396, 5397, 5440, 5441, 5444, 5445, 5456, 5457, 5460, 5461, 16384, 16385, 16388,\r\n            16389, 16400, 16401, 16404, 16405, 16448, 16449, 16452, 16453, 16464, 16465, 16468, 16469,\r\n            16640, 16641, 16644, 16645, 16656, 16657, 16660, 16661, 16704, 16705, 16708, 16709, 16720,\r\n            16721, 16724, 16725, 17408, 17409, 17412, 17413, 17424, 17425, 17428, 17429, 17472, 17473,\r\n            17476, 17477, 17488, 17489, 17492, 17493, 17664, 17665, 17668, 17669, 17680, 17681, 17684,\r\n            17685, 17728, 17729, 17732, 17733, 17744, 17745, 17748, 17749, 20480, 20481, 20484, 20485,\r\n            20496, 20497, 20500, 20501, 20544, 20545, 20548, 20549, 20560, 20561, 20564, 20565, 20736,\r\n            20737, 20740, 20741, 20752, 20753, 20756, 20757, 20800, 20801, 20804, 20805, 20816, 20817,\r\n            20820, 20821, 21504, 21505, 21508, 21509, 21520, 21521, 21524, 21525, 21568, 21569, 21572,\r\n            21573, 21584, 21585, 21588, 21589, 21760, 21761, 21764, 21765, 21776, 21777, 21780, 21781,\r\n            21824, 21825, 21828, 21829, 21840, 21841, 21844, 21845]);\r\n\r\n        this.jrll = new Int16Array([2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4]);\r\n        this.jpll = new Int16Array([1, 3, 5, 7, 0, 2, 4, 6, 1, 3, 5, 7]);\r\n\r\n        this.xoffset = new Int16Array([-1, -1, 0, 1, 1, 1, 0, -1]);\r\n        this.yoffset = new Int16Array([0, 1, 1, 1, 0, -1, -1, -1]);\r\n        this.facearray = [\r\n            new Int16Array([8, 9, 10, 11, -1, -1, -1, -1, 10, 11, 8, 9]),// S\r\n            new Int16Array([5, 6, 7, 4, 8, 9, 10, 11, 9, 10, 11, 8]),// SE\r\n            new Int16Array([-1, -1, -1, -1, 5, 6, 7, 4, -1, -1, -1, -1]),// E\r\n            new Int16Array([4, 5, 6, 7, 11, 8, 9, 10, 11, 8, 9, 10]), // SW\r\n            new Int16Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]),// center\r\n            new Int16Array([1, 2, 3, 0, 0, 1, 2, 3, 5, 6, 7, 4]),// NE\r\n            new Int16Array([-1, -1, -1, -1, 7, 4, 5, 6, -1, -1, -1, -1]),// W\r\n            new Int16Array([3, 0, 1, 2, 3, 0, 1, 2, 4, 5, 6, 7]),// NW\r\n            new Int16Array([2, 3, 0, 1, -1, -1, -1, -1, 0, 1, 2, 3])// N\r\n        ];\r\n        // questo forse deve essere un UInt8Array. Viene usato da neighbours\r\n        this.swaparray = [\r\n            new Int16Array([0, 0, 3]),// S\r\n            new Int16Array([0, 0, 6]),// SE\r\n            new Int16Array([0, 0, 0]),// E\r\n            new Int16Array([0, 0, 5]), // SW\r\n            new Int16Array([0, 0, 0]),// center\r\n            new Int16Array([5, 0, 0]),// NE\r\n            new Int16Array([0, 0, 0]),// W\r\n            new Int16Array([6, 0, 0]),// NW\r\n            new Int16Array([3, 0, 0])// N\r\n        ];\r\n        if (nside_in <= this.ns_max && nside_in > 0) {\r\n            this.nside = nside_in;\r\n            this.npface = this.nside * this.nside;\r\n            this.npix = 12 * this.npface;\r\n            this.order = this.nside2order(this.nside);\r\n            this.nl2 = 2 * this.nside;\r\n            this.nl3 = 3 * this.nside;\r\n            this.nl4 = 4 * this.nside;\r\n            this.fact2 = 4.0 / this.npix;\r\n            this.fact1 = (this.nside << 1) * this.fact2;\r\n            this.ncap = 2 * this.nside * (this.nside - 1); // pixels in each polar cap\r\n            // console.log(\"order: \"+this.order);\r\n            // console.log(\"nside: \"+this.nside);\r\n\r\n        }\r\n\r\n        this.bn = [];\r\n        this.mpr = [];\r\n        this.cmpr = [];\r\n        this.smpr = [];\r\n\r\n        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT\r\n        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT\r\n        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT\r\n        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT\r\n        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT\r\n        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT\r\n        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT\r\n        // Uncaught RangeError: Maximum call stack size exceeded\r\n        // MOVED TO computeBn()\r\n        //        for (let i=0; i <= this.order_max; ++i) {\r\n        //        \tthis.bn[i]=new Healpix(1<<i);\r\n        //        \tthis.mpr[i]=bn[i].maxPixrad();\r\n        //        \tthis.cmpr[i]=Math.cos(mpr[i]);\r\n        //        \tthis.smpr[i]=Math.sin(mpr[i]);\r\n        //        }\r\n\r\n    }\r\n\r\n\r\n    computeBn(): void {\r\n        for (let i = 0; i <= this.order_max; ++i) {\r\n            this.bn[i] = new Healpix(1 << i);\r\n            this.mpr[i] = this.bn[i].maxPixrad();\r\n            this.cmpr[i] = Hploc.cos(this.mpr[i]);\r\n            this.smpr[i] = Hploc.sin(this.mpr[i]);\r\n        }\r\n    }\r\n\r\n    getNPix(): number {\r\n        return this.npix;\r\n    };\r\n\r\n\r\n    getBoundaries(pix: number): Vec3[] {\r\n        let points = new Array<Vec3>();\r\n        let xyf = this.nest2xyf(pix);\r\n\r\n        let dc = 0.5 / this.nside;\r\n        let xc = (xyf.ix + 0.5) / this.nside;\r\n        let yc = (xyf.iy + 0.5) / this.nside;\r\n\r\n        points[0] = new Fxyf(xc + dc, yc + dc, xyf.face).toVec3();\r\n        points[1] = new Fxyf(xc - dc, yc + dc, xyf.face).toVec3();\r\n        points[2] = new Fxyf(xc - dc, yc - dc, xyf.face).toVec3();\r\n        points[3] = new Fxyf(xc + dc, yc - dc, xyf.face).toVec3();\r\n        return points;\r\n    };\r\n\r\n\r\n    /** Returns a set of points along the boundary of the given pixel.\r\n     * Step 1 gives 4 points on the corners. The first point corresponds\r\n     * to the northernmost corner, the subsequent points follow the pixel\r\n     * boundary through west, south and east corners.\r\n     *\r\n     * @param pix pixel index number\r\n     * @param step the number of returned points is 4*step\r\n     * @return {@link Vec3} for each point\r\n     */\r\n    getBoundariesWithStep(pix: number, step: number): Vec3[] {\r\n        // var points = new Array(); \r\n        let points = new Array<Vec3>();\r\n        let xyf = this.nest2xyf(pix);\r\n        let dc = 0.5 / this.nside;\r\n        let xc = (xyf.ix + 0.5) / this.nside;\r\n        let yc = (xyf.iy + 0.5) / this.nside;\r\n        let d = 1.0 / (this.nside * step);\r\n\r\n        for (let i = 0; i < step; i++) {\r\n            points[i] = new Fxyf(xc + dc - i * d, yc + dc, xyf.face).toVec3();\r\n            points[i + step] = new Fxyf(xc - dc, yc + dc - i * d, xyf.face).toVec3();\r\n            points[i + 2 * step] = new Fxyf(xc - dc + i * d, yc - dc, xyf.face).toVec3();\r\n            points[i + 3 * step] = new Fxyf(xc + dc, yc - dc + i * d, xyf.face).toVec3();\r\n        }\r\n        return points;\r\n    };\r\n\r\n    getPointsForXyfNoStep(x: number, y: number, face: number): Vec3[] {\r\n        // let nside = Math.pow(2, this.order);\r\n        let points = new Array<Vec3>();\r\n        let xyf = new Xyf(x, y, face);\r\n\r\n        let dc = 0.5 / this.nside;\r\n        let xc = (xyf.ix + 0.5) / this.nside;\r\n        let yc = (xyf.iy + 0.5) / this.nside;\r\n\r\n        points[0] = new Fxyf(xc + dc, yc + dc, xyf.face).toVec3();\r\n        points[1] = new Fxyf(xc - dc, yc + dc, xyf.face).toVec3();\r\n        points[2] = new Fxyf(xc - dc, yc - dc, xyf.face).toVec3();\r\n        points[3] = new Fxyf(xc + dc, yc - dc, xyf.face).toVec3();\r\n\r\n        return points;\r\n\r\n    }\r\n\r\n    getPointsForXyf(x: number, y: number, step: number, face: number): Vec3[] {\r\n        let nside = step * Math.pow(2, this.order);\r\n        let points = new Array<Vec3>();\r\n        let xyf = new Xyf(x, y, face);\r\n\r\n        let dc = 0.5 / nside;\r\n        let xc = (xyf.ix + 0.5) / nside;\r\n        let yc = (xyf.iy + 0.5) / nside;\r\n\r\n        points[0] = new Fxyf(xc + dc, yc + dc, xyf.face).toVec3();\r\n        points[1] = new Fxyf(xc - dc, yc + dc, xyf.face).toVec3();\r\n        points[2] = new Fxyf(xc - dc, yc - dc, xyf.face).toVec3();\r\n        points[3] = new Fxyf(xc + dc, yc - dc, xyf.face).toVec3();\r\n\r\n        return points;\r\n    }\r\n\r\n    /** Returns the neighboring pixels of ipix.\r\n    This method works in both RING and NEST schemes, but is\r\n    considerably faster in the NEST scheme.\r\n    @param ipix the requested pixel number.\r\n    @return array with indices of the neighboring pixels.\r\n      The returned array contains (in this order)\r\n      the pixel numbers of the SW, W, NW, N, NE, E, SE and S neighbor\r\n      of ipix. If a neighbor does not exist (this can only happen\r\n      for the W, N, E and S neighbors), its entry is set to -1. */\r\n    neighbours(ipix: number): Int32Array {\r\n        let result = new Int32Array(8);\r\n        let xyf = this.nest2xyf(ipix);\r\n        let ix = xyf.ix;\r\n        let iy = xyf.iy;\r\n        let face_num = xyf.face;\r\n\r\n        var nsm1 = this.nside - 1;\r\n        if ((ix > 0) && (ix < nsm1) && (iy > 0) && (iy < nsm1)) {\r\n            let fpix = Math.floor(face_num << (2 * this.order));\r\n            let px0 = this.spread_bits(ix);\r\n            let py0 = this.spread_bits(iy) << 1;\r\n            let pxp = this.spread_bits(ix + 1);\r\n            let pyp = this.spread_bits(iy + 1) << 1;\r\n            let pxm = this.spread_bits(ix - 1);\r\n            let pym = this.spread_bits(iy - 1) << 1;\r\n\r\n            result[0] = fpix + pxm + py0;\r\n            result[1] = fpix + pxm + pyp;\r\n            result[2] = fpix + px0 + pyp;\r\n            result[3] = fpix + pxp + pyp;\r\n            result[4] = fpix + pxp + py0;\r\n            result[5] = fpix + pxp + pym;\r\n            result[6] = fpix + px0 + pym;\r\n            result[7] = fpix + pxm + pym;\r\n        } else {\r\n            for (let i = 0; i < 8; ++i) {\r\n                let x = ix + this.xoffset[i];\r\n                let y = iy + this.yoffset[i];\r\n                let nbnum = 4;\r\n                if (x < 0) {\r\n                    x += this.nside;\r\n                    nbnum -= 1;\r\n                } else if (x >= this.nside) {\r\n                    x -= this.nside;\r\n                    nbnum += 1;\r\n                }\r\n                if (y < 0) {\r\n                    y += this.nside;\r\n                    nbnum -= 3;\r\n                } else if (y >= this.nside) {\r\n                    y -= this.nside;\r\n                    nbnum += 3;\r\n                }\r\n\r\n                let f = this.facearray[nbnum][face_num];\r\n\r\n                if (f >= 0) {\r\n                    let bits = this.swaparray[nbnum][face_num >>> 2];\r\n                    if ((bits & 1) > 0) {\r\n                        x = Math.floor(this.nside - x - 1);\r\n                    }\r\n                    if ((bits & 2) > 0) {\r\n                        y = Math.floor(this.nside - y - 1);\r\n                    }\r\n                    if ((bits & 4) > 0) {\r\n                        let tint = x;\r\n                        x = y;\r\n                        y = tint;\r\n                    }\r\n                    result[i] = this.xyf2nest(x, y, f);\r\n                } else {\r\n                    result[i] = -1;\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n\r\n\r\n    nside2order(nside: number): number {\r\n        return ((nside & (nside - 1)) != 0) ? -1 : Math.log2(nside);\r\n    };\r\n\r\n    nest2xyf(ipix: number): Xyf {\r\n        let pix = Math.floor(ipix & (this.npface - 1));\r\n        let xyf = new Xyf(this.compress_bits(pix), this.compress_bits(pix >> 1),\r\n            Math.floor((ipix >> (2 * this.order))));\r\n        return xyf;\r\n    };\r\n\r\n\r\n    xyf2nest(ix: number, iy: number, face_num: number): number {\r\n\r\n        return Math.floor(face_num << (2 * this.order))\r\n            + this.spread_bits(ix) + (this.spread_bits(iy) << 1);\r\n    };\r\n\r\n    loc2pix(hploc: Hploc): number {\r\n        let z = hploc.z;\r\n        let phi = hploc.phi;\r\n\r\n        let za = Math.abs(z);\r\n        let tt = this.fmodulo((phi * this.inv_halfpi), 4.0);// in [0,4)\r\n        let pixNo: number;\r\n        if (za <= this.twothird) {// Equatorial region\r\n            let temp1 = this.nside * (0.5 + tt);\r\n            let temp2 = this.nside * (z * 0.75);\r\n            let jp = Math.floor(temp1 - temp2); // index of ascending edge line\r\n            let jm = Math.floor(temp1 + temp2); // index of descending edge line\r\n            let ifp = Math.floor(jp >>> this.order);  // in {0,4}\r\n            let ifm = Math.floor(jm >>> this.order);\r\n            let face_num = Math.floor((ifp == ifm) ? (ifp | 4) : ((ifp < ifm) ? ifp : (ifm + 8)));\r\n            let ix = Math.floor(jm & (this.nside - 1));\r\n            let iy = Math.floor(this.nside - (jp & (this.nside - 1)) - 1);\r\n            pixNo = this.xyf2nest(ix, iy, face_num);\r\n        } else { // polar region, za > 2/3\r\n            let ntt = Math.min(3, Math.floor(tt));\r\n            let tp = tt - ntt;\r\n            let tmp = ((za < 0.99) || (!hploc.have_sth)) ?\r\n                this.nside * Math.sqrt(3 * (1 - za)) :\r\n                this.nside * hploc.sth / Math.sqrt((1.0 + za) / 3.);\r\n            let jp = Math.floor(tp * tmp); // increasing edge line index\r\n            let jm = Math.floor((1.0 - tp) * tmp); // decreasing edge line index\r\n            if (jp >= this.nside) {\r\n                jp = this.nside - 1; // for points too close to the boundary\r\n            }\r\n            if (jm >= this.nside) {\r\n                jm = this.nside - 1;\r\n            }\r\n\r\n            if (z >= 0) {\r\n                pixNo = this.xyf2nest(Math.floor(this.nside - jm - 1), Math.floor(this.nside - jp - 1), ntt);\r\n            } else {\r\n                pixNo = this.xyf2nest(Math.floor(jp), Math.floor(jm), ntt + 8);\r\n            }\r\n\r\n        }\r\n        return pixNo;\r\n    };\r\n\r\n\r\n    /** Returns the normalized 3-vector corresponding to the center of the\r\n    supplied pixel.\r\n    @param pix long the requested pixel number.\r\n    @return the pixel's center coordinates. */\r\n    pix2vec(pix: number): Vec3 {\r\n        return this.pix2loc(pix).toVec3();\r\n    };\r\n\r\n    /** Returns the Zphi corresponding to the center of the supplied pixel.\r\n     @param pix the requested pixel number.\r\n     @return the pixel's center coordinates. */\r\n    pix2zphi(pix: number): Zphi {\r\n        return this.pix2loc(pix).toZphi();\r\n    }\r\n\r\n\r\n    pix2ang(pix: number, mirror?: boolean): Pointing { \r\n        return this.pix2loc(pix).toPointing(mirror); \r\n    }\r\n\r\n\r\n    /**\r\n     * @param pix long\r\n     * @return Hploc\r\n     */\r\n    pix2loc(pix: number): Hploc {\r\n        let loc = new Hploc(undefined);\r\n\r\n\r\n        let xyf = this.nest2xyf(pix);\r\n\r\n        let jr = ((this.jrll[xyf.face]) << this.order) - xyf.ix - xyf.iy - 1;\r\n\r\n        let nr;\r\n        if (jr < this.nside) {\r\n            nr = jr;\r\n            let tmp = (nr * nr) * this.fact2;\r\n            loc.z = 1 - tmp;\r\n            if (loc.z > 0.99) {\r\n                loc.sth = Math.sqrt(tmp * (2. - tmp));\r\n                loc.have_sth = true;\r\n            }\r\n        } else if (jr > this.nl3) {\r\n            nr = this.nl4 - jr;\r\n            let tmp = (nr * nr) * this.fact2;\r\n            loc.z = tmp - 1;\r\n            if (loc.z < -0.99) {\r\n                loc.sth = Math.sqrt(tmp * (2. - tmp));\r\n                loc.have_sth = true;\r\n            }\r\n        } else {\r\n            nr = this.nside;\r\n            loc.z = (this.nl2 - jr) * this.fact1;\r\n        }\r\n\r\n        let tmp = (this.jpll[xyf.face]) * nr + xyf.ix - xyf.iy;\r\n        //      \tassert(tmp<8*nr); // must not happen\r\n        if (tmp < 0) {\r\n            tmp += 8 * nr;\r\n        }\r\n        loc.phi = (nr == this.nside) ? 0.75 * Constants.halfpi * tmp * this.fact1 : (0.5 * Constants.halfpi * tmp) / nr;\r\n        // loc.setPhi((nr == this.nside) ? 0.75 * Constants.halfpi * tmp * this.fact1 : (0.5 * Constants.halfpi * tmp)/nr);\r\n        return loc;\r\n    };\r\n\r\n    za2vec(z: number, a: number): Vec3 {\r\n        const sin_theta = Math.sqrt(1 - z * z)\r\n        const X = sin_theta * Math.cos(a)\r\n        const Y = sin_theta * Math.sin(a)\r\n        return new Vec3(X, Y, z)\r\n    }\r\n\r\n\r\n    ang2vec(theta: number, phi: number) {\r\n        const z = Math.cos(theta)\r\n        return this.za2vec(z, phi)\r\n    }\r\n\r\n    vec2ang(v: Vec3) {\r\n        const { z, a } = this.vec2za(v.getX(), v.getY(), v.getZ())\r\n        return { theta: Math.acos(z), phi: a }\r\n    }\r\n\r\n    vec2za(X: number, Y: number, z: number) {\r\n        const r2 = X * X + Y * Y\r\n        if (r2 == 0)\r\n            return { z: z < 0 ? -1 : 1, a: 0 }\r\n        else {\r\n            const PI2 = Math.PI / 2\r\n            const a = (Math.atan2(Y, X) + PI2) % PI2\r\n            z /= Math.sqrt(z * z + r2)\r\n            return { z, a }\r\n        }\r\n    }\r\n\r\n\r\n    ang2pix(ptg: Pointing, mirror?: boolean) {\r\n        return this.loc2pix(new Hploc(ptg));\r\n    };\r\n\r\n    fmodulo(v1: number, v2: number): number {\r\n        if (v1 >= 0) {\r\n            return (v1 < v2) ? v1 : v1 % v2;\r\n        }\r\n        var tmp = v1 % v2 + v2;\r\n        return (tmp === v2) ? 0.0 : tmp;\r\n    };\r\n\r\n    compress_bits(v: number): number {\r\n        var raw = Math.floor((v & 0x5555)) | Math.floor(((v & 0x55550000) >>> 15));\r\n        var compressed = this.ctab[raw & 0xff] | (this.ctab[raw >>> 8] << 4);\r\n        return compressed;\r\n    };\r\n\r\n\r\n    spread_bits(v: number): number {\r\n        return Math.floor(this.utab[v & 0xff]) | Math.floor((this.utab[(v >>> 8) & 0xff] << 16))\r\n            | Math.floor((this.utab[(v >>> 16) & 0xff] << 32)) | Math.floor((this.utab[(v >>> 24) & 0xff] << 48));\r\n    };\r\n\r\n\r\n    /**\r\n     * Returns a range set of pixels that overlap with the convex polygon\r\n     * defined by the {@code vertex} array.\r\n     * <p>\r\n     * This method is more efficient in the RING scheme.\r\n     * <p>\r\n     * This method may return some pixels which don't overlap with the polygon\r\n     * at all. The higher {@code fact} is chosen, the fewer false positives are\r\n     * returned, at the cost of increased run time.\r\n     * \r\n     * @param vertex\r\n     *            an array containing the vertices of the requested convex\r\n     *            polygon.\r\n     * @param fact\r\n     *            The overlapping test will be done at the resolution\r\n     *            {@code fact*nside}. For NESTED ordering, {@code fact} must be\r\n     *            a power of 2, else it can be any positive integer. A typical\r\n     *            choice would be 4.\r\n     * @return the requested set of pixel number ranges\r\n     */\r\n    queryPolygonInclusive(vertex: Pointing[], fact: number): RangeSet {\r\n        let inclusive = (fact != 0);\r\n        let nv = vertex.length;\r\n        //        let ncirc = inclusive ? nv+1 : nv;\r\n\r\n        if (!(nv >= 3)) {\r\n            console.log(\"not enough vertices in polygon\");\r\n            return;\r\n        }\r\n        let vv = new Array<Vec3>();\r\n        for (let i = 0; i < nv; ++i) {\r\n            vv[i] = Vec3.pointing2Vec3(vertex[i]);\r\n        }\r\n\r\n\r\n        let normal = new Array<Vec3>();\r\n        let flip = 0;\r\n        let index = 0;\r\n        let back = false;\r\n\r\n        while (index < vv.length) {\r\n\r\n            let first = vv[index];\r\n            let medium = null;\r\n            let last = null;\r\n\r\n            if (index == vv.length - 1) {\r\n                last = vv[1];\r\n                medium = vv[0];\r\n            } else if (index == vv.length - 2) {\r\n                last = vv[0];\r\n                medium = vv[index + 1];\r\n            } else {\r\n                medium = vv[index + 1];\r\n                last = vv[index + 2];\r\n            }\r\n\r\n            normal[index] = first.cross(medium).norm();\r\n            let hnd = normal[index].dot(last);\r\n\r\n            if (index == 0) {\r\n                flip = (hnd < 0.) ? -1 : 1;\r\n\r\n                let tmp = new Pointing(first); // TODO not used\r\n                back = false;\r\n            } else {\r\n                let flipThnd = flip * hnd;\r\n                if (flipThnd < 0) {\r\n                    let tmp = new Pointing(medium);\r\n                    vv.splice(index + 1, 1);\r\n                    normal.splice(index, 1);\r\n                    back = true;\r\n                    index -= 1;\r\n                    continue;\r\n                } else {\r\n                    let tmp = new Pointing(first);\r\n                    back = false;\r\n                }\r\n            }\r\n\r\n\r\n            normal[index].scale(flip);\r\n            index += 1;\r\n\r\n        }\r\n        nv = vv.length;\r\n        let ncirc = inclusive ? nv + 1 : nv;\r\n\r\n        let rad = new Array(ncirc);\r\n        rad = rad.fill(Constants.halfpi);\r\n        //        rad = rad.fill(1.5707963267948966);\r\n        //        let p = \"1.5707963267948966\";\r\n        //        rad = rad.fill(parseFloat(p));\r\n\r\n        if (inclusive) {\r\n            let cf = new CircleFinder(vv);\r\n            normal[nv] = cf.getCenter();\r\n            rad[nv] = Hploc.acos(cf.getCosrad());\r\n        }\r\n        return this.queryMultiDisc(normal, rad, fact);\r\n\r\n    };\r\n\r\n    /**\r\n     * For NEST schema only\r\n     * \r\n     * @param normal:\r\n     *            Vec3[]\r\n     * @param rad:\r\n     *            Float32Array\r\n     * @param fact:\r\n     *            The overlapping test will be done at the resolution\r\n     *            {@code fact*nside}. For NESTED ordering, {@code fact} must be\r\n     *            a power of 2, else it can be any positive integer. A typical\r\n     *            choice would be 4.\r\n     * @return RangeSet the requested set of pixel number ranges\r\n     */\r\n    queryMultiDisc(norm: Vec3[], rad: number[], fact: number): RangeSet {\r\n        this.computeBn();\r\n\r\n        let inclusive = (fact != 0);\r\n        let nv = norm.length;\r\n        // HealpixUtils.check(nv==rad.lengt0,\"inconsistent input arrays\");\r\n        if (!(nv == rad.length)) {\r\n            console.error(\"inconsistent input arrays\");\r\n            return;\r\n        }\r\n\r\n        let res = new RangeSet(4 << 1);\r\n        // Removed code for Scheme.RING\r\n        let oplus = 0;\r\n        if (inclusive) {\r\n            if (!(Math.pow(2, this.order_max - this.order) >= fact)) {\r\n                console.error(\"invalid oversampling factor\");\r\n            }\r\n            if (!((fact & (fact - 1)) == 0)) {\r\n                console.error(\"oversampling factor must be a power of 2\");\r\n            }\r\n\r\n            oplus = this.ilog2(fact);\r\n\r\n        }\r\n        let omax = this.order + oplus; // the order up to which we test\r\n\r\n        // TODO: ignore all disks with radius>=pi\r\n\r\n        //        let crlimit = new Float32Array[omax+1][nv][3];\r\n        let crlimit = new Array(omax + 1);\r\n        let o: number;\r\n        let i: number;\r\n        for (o = 0; o <= omax; ++o) { // prepare data at the required orders\r\n            crlimit[o] = new Array(nv);\r\n            let dr = this.bn[o].maxPixrad(); // safety distance\r\n            for (i = 0; i < nv; ++i) {\r\n\r\n                crlimit[o][i] = new Float64Array(3);\r\n                crlimit[o][i][0] = (rad[i] + dr > Math.PI) ? -1 : Hploc.cos(rad[i] + dr);\r\n                crlimit[o][i][1] = (o == 0) ? Hploc.cos(rad[i]) : crlimit[0][i][1];\r\n                crlimit[o][i][2] = (rad[i] - dr < 0.) ? 1. : Hploc.cos(rad[i] - dr);\r\n            }\r\n        }\r\n\r\n        let stk = new pstack(12 + 3 * omax);\r\n        for (let i = 0; i < 12; i++) { // insert the 12 base pixels in reverse\r\n            // order\r\n            stk.push(11 - i, 0);\r\n        }\r\n\r\n        while (stk.size() > 0) { // as long as there are pixels on the stack\r\n            // pop current pixel number and order from the stack\r\n            let pix = stk.ptop();\r\n            let o = stk.otop();\r\n            stk.pop();\r\n\r\n            let pv = this.bn[o].pix2vec(pix);\r\n\r\n            let zone = 3;\r\n            for (let i = 0; (i < nv) && (zone > 0); ++i) {\r\n                let crad = pv.dot(norm[i]);\r\n                for (let iz = 0; iz < zone; ++iz) {\r\n                    if (crad < crlimit[o][i][iz]) {\r\n                        zone = iz;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (zone > 0) {\r\n                this.check_pixel(o, omax, zone, res, pix, stk, inclusive);\r\n            }\r\n        }\r\n        return res;\r\n    };\r\n\r\n    /** Integer base 2 logarithm.\r\n    @param arg\r\n    @return the largest integer {@code n} that fulfills {@code 2^n<=arg}.\r\n    For negative arguments and zero, 0 is returned. */\r\n    ilog2(arg: number): number {\r\n        let max = Math.max(arg, 1);\r\n        return 31 - Math.clz32(max);\r\n    };\r\n\r\n    /** Computes the cosine of the angular distance between two z, phi positions\r\n      on the unit sphere. */\r\n    cosdist_zphi(z1: number, phi1: number, z2: number, phi2: number): number {\r\n        return z1 * z2 + Hploc.cos(phi1 - phi2) * Math.sqrt((1.0 - z1 * z1) * (1.0 - z2 * z2));\r\n    }\r\n\r\n    /**\r\n     * @param int o\r\n     * @param int omax\r\n     * @param int zone\r\n     * @param RangeSet pixset\r\n     * @param long pix\r\n     * @param pstack stk\r\n     * @param boolean inclusive\r\n     */\r\n    check_pixel(o: number, omax: number, zone: number, pixset: RangeSet, pix: number, stk: pstack, inclusive: boolean) {\r\n\r\n        if (zone == 0) return;\r\n\r\n        if (o < this.order) {\r\n            if (zone >= 3) {// output all subpixels\r\n                let sdist = 2 * (this.order - o); // the \"bit-shift distance\" between map orders\r\n                pixset.append1(pix << sdist, ((pix + 1) << sdist));\r\n            } else {// (zone>=1)\r\n                for (let i = 0; i < 4; ++i) {\r\n                    stk.push(4 * pix + 3 - i, o + 1); // add children\r\n                }\r\n            }\r\n        } else if (o > this.order) {// this implies that inclusive==true\r\n\r\n            if (zone >= 2) {// pixel center in shape\r\n                pixset.append(pix >>> (2 * (o - this.order))); // output the parent pixel at order\r\n                stk.popToMark(); // unwind the stack\r\n            } else {// (zone>=1): pixel center in safety range\r\n                if (o < omax) {// check sublevels\r\n                    for (let i = 0; i < 4; ++i) { // add children in reverse order\r\n                        stk.push(4 * pix + 3 - i, o + 1); // add children\r\n                    }\r\n                } else {// at resolution limit\r\n                    pixset.append(pix >>> (2 * (o - this.order)));// output the parent pixel at order\r\n                    stk.popToMark(); // unwind the stack\r\n                }\r\n            }\r\n        } else {// o==order\r\n            if (zone >= 2) {\r\n                pixset.append(pix);\r\n            } else if (inclusive) {// and (zone>=1)\r\n                if (this.order < omax) {// check sublevels\r\n                    stk.mark(); // remember current stack position\r\n                    for (let i = 0; i < 4; ++i) { // add children in reverse order\r\n                        stk.push(4 * pix + 3 - i, o + 1); // add children\r\n                    }\r\n                } else {// at resolution limit\r\n                    pixset.append(pix); // output the pixel\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Returns the maximum angular distance between a pixel center and its\r\n    corners.\r\n    @return maximum angular distance between a pixel center and its\r\n      corners. */\r\n    maxPixrad() {\r\n\r\n        let zphia = new Zphi(2. / 3., Math.PI / this.nl4);\r\n        let xyz1 = this.convertZphi2xyz(zphia);\r\n\r\n        let va = new Vec3(xyz1[0], xyz1[1], xyz1[2]);\r\n        let t1 = 1. - 1. / this.nside;\r\n        t1 *= t1;\r\n\r\n\r\n        let zphib = new Zphi(1 - t1 / 3, 0);\r\n        let xyz2 = this.convertZphi2xyz(zphib);\r\n\r\n        let vb = new Vec3(xyz2[0], xyz2[1], xyz2[2]);\r\n        return va.angle(vb);\r\n    };\r\n\r\n\r\n\r\n    /**\r\n     * this is a workaround replacing the Vec3(Zphi) constructor.\r\n     */\r\n    convertZphi2xyz(zphi: Zphi): [number, number, number] {\r\n\r\n        let sth = Math.sqrt((1.0 - zphi.z) * (1.0 + zphi.z));\r\n        let x = sth * Hploc.cos(zphi.phi);\r\n        let y = sth * Hploc.sin(zphi.phi);\r\n        let z = zphi.z;\r\n        return [x, y, z];\r\n\r\n    };\r\n\r\n    /** Returns a range set of pixels which overlap with a given disk. <p>\r\n      This method is more efficient in the RING scheme. <p>\r\n      This method may return some pixels which don't overlap with\r\n      the polygon at all. The higher {@code fact} is chosen, the fewer false\r\n      positives are returned, at the cost of increased run time.\r\n      @param ptg the angular coordinates of the disk center\r\n      @param radius the radius (in radians) of the disk\r\n      @param fact The overlapping test will be done at the resolution\r\n        {@code fact*nside}. For NESTED ordering, {@code fact} must be a power\r\n        of 2, else it can be any positive integer. A typical choice would be 4.\r\n      @return the requested set of pixel number ranges  */\r\n    queryDiscInclusive(ptg: Pointing, radius: number, fact: number): RangeSet {\r\n        this.computeBn();\r\n        let inclusive = (fact != 0);\r\n        let pixset = new RangeSet();\r\n\r\n        if (radius >= Math.PI) {// disk covers the whole sphere\r\n            pixset.append1(0, this.npix); return pixset;\r\n        }\r\n\r\n        let oplus = 0;\r\n        if (inclusive) {\r\n            // HealpixUtils.check ((1L<<order_max)>=fact,\"invalid oversampling factor\");\r\n\r\n            if (!((fact & (fact - 1)) == 0)) {\r\n                console.error(\"oversampling factor must be a power of 2\");\r\n            }\r\n            oplus = this.ilog2(fact);\r\n        }\r\n\r\n        let omax = Math.min(this.order_max, this.order + oplus); // the order up to which we test\r\n        let vptg = Vec3.pointing2Vec3(ptg);\r\n        let crpdr = new Array(omax + 1);\r\n        let crmdr = new Array(omax + 1);\r\n\r\n        let cosrad = Hploc.cos(radius);\r\n        let sinrad = Hploc.sin(radius);\r\n        for (let o = 0; o <= omax; o++) {// prepare data at the required orders\r\n\r\n            let dr = this.mpr[o]; // safety distance\r\n            let cdr = this.cmpr[o];\r\n            let sdr = this.smpr[o];\r\n            crpdr[o] = (radius + dr > Math.PI) ? -1. : cosrad * cdr - sinrad * sdr;\r\n            crmdr[o] = (radius - dr < 0.) ? 1. : cosrad * cdr + sinrad * sdr;\r\n        }\r\n\r\n        let stk = new pstack(12 + 3 * omax);\r\n        for (let i = 0; i < 12; i++) {// insert the 12 base pixels in reverse order\r\n            stk.push(11 - i, 0);\r\n        }\r\n\r\n        while (stk.size() > 0) {// as long as there are pixels on the stack\r\n            // pop current pixel number and order from the stack\r\n            let pix = stk.ptop();\r\n            let curro = stk.otop();\r\n            stk.pop();\r\n\r\n            let pos = this.bn[curro].pix2zphi(pix);\r\n            // cosine of angular distance between pixel center and disk center\r\n            let cangdist = this.cosdist_zphi(vptg.z, ptg.phi, pos.z, pos.phi);\r\n\r\n            if (cangdist > crpdr[curro]) {\r\n                let zone = (cangdist < cosrad) ? 1 : ((cangdist <= crmdr[curro]) ? 2 : 3);\r\n                this.check_pixel(curro, omax, zone, pixset, pix, stk, inclusive);\r\n            }\r\n        }\r\n        return pixset;\r\n    }\r\n\r\n}\r\n\r\n// export default Healpix;\r\n// export {\r\n//     Hploc,\r\n//     Vec3,\r\n//     Pointing\r\n// };"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","Constants","halfpi","inv_halfpi","Math","PI","twopi","inv_twopi","pstack","constructor","sz","this","p","Array","Int32Array","s","m","push","p_","o_","pop","popToMark","size","mark","otop","ptop","Pointing","vec3","mirror","in_theta","in_phi","theta","Hploc","atan2","sqrt","x","y","z","phi","Zphi","z_","phi_","ptg","PI4_A","PI4_B","PI4_C","M_1_PI","sth","have_sth","cos","_phi","abs","sin","setZ","setSth","toPointing","st","toVec3","Vec3","toZphi","static","d","u","q","floor","sincoshelper","mulsign","atan2k","copySign","magnitude","sign","t","atanhelper","r","isinf","isnan","NaN","in_x","in_y","in_z","getX","getY","getZ","scale","n","cross","v","add","normalize","length","norm","lengthSquared","dot","v1","sub","angle","flip","pointing","CircleFinder","point","np","center","cosrad","i","getCircle","console","log","getCircle2","q1","q2","getCenter","getCosrad","Fxyf","f","fx","fy","face","jrll","Uint8Array","jpll","toHploc","nr","loc","jr","tmp","RangeSet","cap","error","append","val","append1","a","b","newsize","max","rnew","set","ensureCapacity","resize","sliced","slice","Xyf","ix","iy","Healpix","nside_in","order_max","twothird","ns_max","pow","ctab","Uint16Array","utab","Int16Array","xoffset","yoffset","facearray","swaparray","nside","npface","npix","order","nside2order","nl2","nl3","nl4","fact2","fact1","ncap","bn","mpr","cmpr","smpr","computeBn","maxPixrad","getNPix","getBoundaries","pix","points","xyf","nest2xyf","dc","xc","yc","getBoundariesWithStep","step","getPointsForXyfNoStep","getPointsForXyf","neighbours","ipix","result","face_num","nsm1","fpix","px0","spread_bits","py0","pxp","pyp","pxm","pym","nbnum","bits","tint","xyf2nest","log2","compress_bits","loc2pix","hploc","pixNo","za","tt","fmodulo","temp1","temp2","jp","jm","ifp","ifm","ntt","min","tp","pix2vec","pix2loc","pix2zphi","pix2ang","undefined","za2vec","sin_theta","X","Y","ang2vec","vec2ang","vec2za","acos","r2","PI2","ang2pix","v2","raw","queryPolygonInclusive","vertex","fact","inclusive","nv","vv","pointing2Vec3","normal","index","back","first","medium","last","hnd","splice","rad","fill","cf","queryMultiDisc","res","oplus","ilog2","omax","crlimit","dr","Float64Array","stk","pv","zone","crad","iz","check_pixel","arg","clz32","cosdist_zphi","z1","phi1","z2","phi2","pixset","sdist","zphia","xyz1","convertZphi2xyz","va","t1","zphib","xyz2","vb","zphi","queryDiscInclusive","radius","vptg","crpdr","crmdr","sinrad","cdr","sdr","curro","pos","cangdist"],"sourceRoot":""}