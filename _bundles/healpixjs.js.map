{"version":3,"file":"healpixjs.js","mappings":"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","sources":["webpack://healpixjs/webpack/universalModuleDefinition","webpack://healpixjs/webpack/bootstrap","webpack://healpixjs/webpack/runtime/define property getters","webpack://healpixjs/webpack/runtime/hasOwnProperty shorthand","webpack://healpixjs/webpack/runtime/make namespace object","webpack://healpixjs/./src/Constants.ts","webpack://healpixjs/./src/pstack.ts","webpack://healpixjs/./src/Zphi.ts","webpack://healpixjs/./src/Hploc.ts","webpack://healpixjs/./src/Pointing.ts","webpack://healpixjs/./src/Vec3.ts","webpack://healpixjs/./src/CircleFinder.ts","webpack://healpixjs/./src/Fxyf.ts","webpack://healpixjs/./src/RangeSet.ts","webpack://healpixjs/./src/Xyf.ts","webpack://healpixjs/./src/Healpix.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"healpixjs\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"healpixjs\"] = factory();\n\telse\n\t\troot[\"healpixjs\"] = factory();\n})(self, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","\n\nexport class Constants{\n  \n  \n//\tstatic halfpi = Math.PI/2.;\n\tstatic halfpi = 1.5707963267948966;\n\t\n\n\tstatic inv_halfpi = 2./Math.PI;\n\t\n\t  /** The Constant twopi. */\n\tstatic twopi = 2*Math.PI;\n\tstatic inv_twopi = 1./(2*Math.PI);\n\n}\n\n","export class pstack{\n\t\n\tp: number[];\n\to: Int32Array;\n\ts: number;\n\tm: number;\n\t\n\t/** Creation from individual components */\n\tconstructor(sz: number){\n    \tthis.p = new Array(sz); \n\t\tthis.o = new Int32Array(sz);\n\t\tthis.s = 0;\n\t\tthis.m = 0;\n\t};\n\t\n\t/**\n\t * @param p long\n\t * @param o int\n\t */\n\tpush (p_: number, o_: number){ \n\t\tthis.p[this.s]= p_; \n\t\tthis.o[this.s]= o_; \n\t\t++this.s;\n\t};\n\t\n  \tpop (){ \n  \t\t--this.s; \n  \t};\n  \n  \tpopToMark (){ \n  \t\tthis.s=this.m; \n  \t};\n  \n\tsize (){ \n\t\treturn this.s; \n\t};\n  \n\n\tmark (){ \n\t\tthis.m=this.s; \n\t};\n  \n\totop (){ \n\t\treturn this.o[this.s-1]; \n\t};\n  \n\tptop (){ \n\t\treturn this.p[this.s-1]; \n\t};\n\t\n}\n","\nexport class Zphi{\n\t\n\tz: number;\n\tphi: number;\n\t\n\t/** Creation from individual components */\n\tconstructor(z_: number, phi_: number){\n    \tthis.z = z_; \n\t\tthis.phi = phi_; \n\t};\n\t\n}","import { Pointing } from './Pointing.js';\nimport {Vec3} from './Vec3.js';\nimport {Zphi} from './Zphi.js';\n\nexport class Hploc{\n\tstatic PI4_A = 0.7853981554508209228515625;\n\tstatic PI4_B = 0.794662735614792836713604629039764404296875e-8;\n\tstatic PI4_C = 0.306161699786838294306516483068750264552437361480769e-16;\n\tstatic M_1_PI = 0.3183098861837906715377675267450287;\n\t\n\tsth: number;\n\thave_sth: boolean;\n\tz: number;\n\t_phi: number;\n\n\n\tconstructor(ptg?: Pointing){\n\t\tHploc.PI4_A = 0.7853981554508209228515625;\n\t\tHploc.PI4_B = 0.794662735614792836713604629039764404296875e-8;\n\t\tHploc.PI4_C = 0.306161699786838294306516483068750264552437361480769e-16;\n\t\tHploc.M_1_PI = 0.3183098861837906715377675267450287;\n\t\tif ( ptg ){\n\t\t\tthis.sth = 0.0;\n\t\t\tthis.have_sth=false;\n\t\t\tthis.z = Hploc.cos(ptg.theta);\n\t\t\tthis._phi = ptg.phi;\n\t\t\tif (Math.abs(this.z)>0.99){\n\t\t\t\tthis.sth = Hploc.sin(ptg.theta);\n\t\t\t\tthis.have_sth=true;\n\t\t\t}\n\t\t}\n\t}\n\n\tsetZ(z: number){\n\t\tthis.z = z;\n\t};\n\t\n\tget phi(): number{\n\t\treturn this._phi;\n\t};\n\n\tset phi(phi: number){\n\t\tthis._phi = phi;\n\t};\n\n\tsetSth(sth: number){\n\t\tthis.sth = sth;\n\t};\n\t\n\ttoVec3(): Vec3{\n\t\tvar st = this.have_sth ? this.sth : Math.sqrt((1.0-this.z)*(1.0+this.z));\n\t\tvar vector = new Vec3(st*Hploc.cos(this.phi),st*Hploc.sin(this.phi),this.z);\n\t\t// var vector = new Vec3(st*Math.cos(this.phi),st*Math.sin(this.phi),this.z);\n\t\treturn vector;\n\t};\n\n\ttoZphi(): Zphi { \n\t\treturn new Zphi(this.z, this.phi); \n\t}\n\n\t\n\tstatic sin(d: number): number{\n\t\t\n\t\tlet u = d * Hploc.M_1_PI;\n\t\tlet q = Math.floor(u < 0 ? u - 0.5 : u + 0.5);\n\t\tlet x = 4.0 * q;\n\t\td -= x * Hploc.PI4_A;\n\t\td -= x * Hploc.PI4_B;\n\t\td -= x * Hploc.PI4_C;\n\t\tif ((q & 1) != 0) {\n\t\t\td = -d;\n\t\t}\n\t\treturn this.sincoshelper(d);\n\t};\n\t\n\t\n\tstatic cos(d: number): number{\n\t\t\n//\t\tlet u = d * Hploc.M_1_PI - 0.5;\n\t\tlet u = d * Hploc.M_1_PI - 0.5;\n//\t\tu -= 0.5;\n\t\tlet q = 1 + 2 * Math.floor(u < 0 ? u - 0.5 : u + 0.5);\n\t\tlet x = 2.0 * q;\n\t\t\n\t\tlet t = x * Hploc.PI4_A;\n\t\td = d - t;\n\t\td -= x * Hploc.PI4_B;\n\t\td -= x * Hploc.PI4_C;\n\t\tif ((q & 2) == 0){\n\t\t\td = -d;\n\t\t}\n\t\treturn Hploc.sincoshelper(d);\n\t};\n\t\n\t\n\tstatic sincoshelper(d: number): number{\n\t\tlet s = d * d;\n\t\tlet u = -7.97255955009037868891952e-18;\n\t\tu = u * s +2.81009972710863200091251e-15;\n\t\tu = u * s -7.64712219118158833288484e-13;\n  \t\tu = u * s +1.60590430605664501629054e-10;\n  \t\tu = u * s -2.50521083763502045810755e-08;\n  \t\tu = u * s +2.75573192239198747630416e-06;\n  \t\tu = u * s -0.000198412698412696162806809;\n  \t\tu = u * s +0.00833333333333332974823815;\n  \t\tu = u * s -0.166666666666666657414808;\n\t\treturn s*u*d + d;\n\t};\n\t\n\t/** This method calculates the arc sine of x in radians. The return\n    value is in the range [-pi/2, pi/2]. The results may have\n    maximum error of 3 ulps. */\n\tstatic asin(d: number): number{ \n\t\treturn Hploc.mulsign(Hploc.atan2k(Math.abs(d), Math.sqrt((1+d)*(1-d))), d); \n\t};\n\t\n/** This method calculates the arc cosine of x in radians. The\n    return value is in the range [0, pi]. The results may have\n    maximum error of 3 ulps. */\n\tstatic acos(d: number): number {\n\t\treturn Hploc.mulsign(Hploc.atan2k(Math.sqrt((1+d)*(1-d)), Math.abs(d)), d) + (d<0 ? Math.PI : 0);\n\t};\n\t\n\tstatic mulsign(x: number, y: number): number{\n\t\tlet sign = Hploc.copySign(1, y);\n\t\treturn sign * x; \n\t};\n\t\n\tstatic copySign(magnitude: number, sign: number): number{\n\n\t\treturn sign < 0 ? -Math.abs(magnitude) : Math.abs(magnitude);\n\t\t// let finalsign = 1;\n\t\t// if (Object.is(finalsign , -0)){\n\t\t// \tsign = -1;\n\t\t// }else if (Object.is(finalsign , 0)){\n\t\t// \tsign = 1;\n\t\t// }else {\n\t\t// \tsign = Math.sign(finalsign);\n\t\t// }\n\t\t// return finalsign * magnitude;\n\t}\n\t\n\tstatic atanhelper(s: number): number{\n\t    let t = s * s;\n\t    let u = -1.88796008463073496563746e-05;\n\t    u = u * t + (0.000209850076645816976906797);\n\t    u = u * t + (-0.00110611831486672482563471);\n\t    u = u * t + (0.00370026744188713119232403);\n\t    u = u * t + (-0.00889896195887655491740809);\n\t    u = u * t + (0.016599329773529201970117);\n\t    u = u * t + (-0.0254517624932312641616861);\n\t    u = u * t + (0.0337852580001353069993897);\n\t    u = u * t + (-0.0407629191276836500001934);\n\t    u = u * t + (0.0466667150077840625632675);\n\t    u = u * t + (-0.0523674852303482457616113);\n\t    u = u * t + (0.0587666392926673580854313);\n\t    u = u * t + (-0.0666573579361080525984562);\n\t    u = u * t + (0.0769219538311769618355029);\n\t    u = u * t + (-0.090908995008245008229153);\n\t    u = u * t + (0.111111105648261418443745);\n\t    u = u * t + (-0.14285714266771329383765);\n\t    u = u * t + (0.199999999996591265594148);\n\t    u = u * t + (-0.333333333333311110369124);\n\t\n\t    return u * t * s + s;\n    };\n\n    static atan2k(y: number, x: number): number {\n\t    let q = 0.;\n\t\n\t    if (x < 0) { \n\t    \tx = -x; \n\t    \tq = -2.; \n\t    }\n\t    if (y > x) { \n\t    \tlet t = x; \n\t    \tx = y; \n\t    \ty = -t; \n\t    \tq += 1.; \n\t    }\n\t    return Hploc.atanhelper(y/x) + q*(Math.PI/2);\n    };\n\n /** This method calculates the arc tangent of y/x in radians, using\n the signs of the two arguments to determine the quadrant of the\n result. The results may have maximum error of 2 ulps. */\n\t static atan2(y: number, x: number): number {\n\t\t let r = Hploc.atan2k(Math.abs(y), x);\n\t\t\t\n\t\t r = Hploc.mulsign(r, x);\n\t\t if (Hploc.isinf(x) || x == 0){\n\t\t\t r = Math.PI/2 - (Hploc.isinf(x) ? (Hploc.copySign(1, x) * (Math.PI /2)) : 0);\n\t\t }\n\t      \n\t\t if (Hploc.isinf(y)){\n\t\t\t r = Math.PI/2 - (Hploc.isinf(x) ? (Hploc.copySign(1, x) * (Math.PI*1/4)) : 0);\n\t\t }\n\t\t\t      \n\t\t if (y == 0){\n\t\t\t r = (Hploc.copySign(1, x) == -1 ? Math.PI : 0);\n\t\t }\n\t\t return Hploc.isnan(x) || Hploc.isnan(y) ? NaN : Hploc.mulsign(r, y);\n\t };\n    \n\t /** Checks if the argument is a NaN or not. */\n\t static isnan(d: number): boolean {\n\t\t return d != d;\n\t };\n\n    /** Checks if the argument is either positive or negative infinity. */\n    static isinf(d:number): boolean{ \n    \treturn Math.abs(d) === +Infinity; \n    };\n\n\n}\n","import { Hploc } from './Hploc.js';\nimport { Vec3 } from './Vec3.js';\n\n\n\nexport class Pointing {\n\n\n\n\ttheta: number;\n\tphi: number;\n\n\t/**\n\t * \n\t * @param {*} vec3 Vec3.js\n\t * @param {*} mirror \n\t * @param {*} in_theta radians\n\t * @param {*} in_phi radians\n\t */\n\tconstructor(vec3: Vec3 | null, mirror?: boolean, in_theta?: number, in_phi?: number) {\n\n\t\tif (vec3 != null) {\n\t\t\tthis.theta = Hploc.atan2(Math.sqrt(vec3.x * vec3.x + vec3.y * vec3.y), vec3.z);\n\t\t\tif (mirror) {\n\t\t\t\tthis.phi = - Hploc.atan2(vec3.y, vec3.x);\n\t\t\t} else {\n\t\t\t\tthis.phi = Hploc.atan2(vec3.y, vec3.x);\n\t\t\t}\n\n\n\t\t\tif (this.phi < 0.0) {\n\t\t\t\tthis.phi = this.phi + 2 * Math.PI;\n\t\t\t}\n\t\t\tif (this.phi >= 2 * Math.PI) {\n\t\t\t\tthis.phi = this.phi - 2 * Math.PI;\n\t\t\t}\n\n\t\t} else {\n\t\t\tthis.theta = in_theta;\n\t\t\tthis.phi = in_phi;\n\t\t}\n\n\t}\n}\n\n","/**\n * Partial porting to Javascript of Vec3.java from Healpix3.30  \n */\n\nimport {Hploc} from './Hploc.js';\nimport {Pointing} from './Pointing.js';\n\n\nexport class Vec3{\n\t\n\tx: number;\n\ty: number;\n\tz: number;\n\t\n\tconstructor(in_x: number | Pointing, in_y: number, in_z: number){\n\n\t\tif (in_x instanceof Pointing) {\n\t\t\tlet ptg = in_x;\n\t\t\tlet sth = Hploc.sin(ptg.theta);\n\t\t\tthis.x=sth*Hploc.cos(ptg.phi);\n\t\t\tthis.y=sth*Hploc.sin(ptg.phi);\n\t\t\tthis.z=Hploc.cos(ptg.theta);\n\t\t}else{\n\t\t\tthis.x = in_x;\n\t\t\tthis.y = in_y;\n\t\t\tthis.z = in_z;\n\t\t}\n\t\t\n\t}\n\tgetX(): number{\n\t\t  return this.x;\n\t};\n\t\t\n\tgetY(): number{\n\t  return this.y;\n\t};\n\t\n\tgetZ(): number{\n\t  return this.z;\n\t};\n\t\n\t/** Scale the vector by a given factor\n    @param n the scale factor */\n\tscale(n: number): void{\n\t\tthis.x *= n; \n\t\tthis.y*=n; \n\t\tthis.z*=n;\n\t};\n\t\n\t/** Vector cross product.\n    @param v another vector\n    @return the vector cross product between this vector and {@code v} */\n\tcross(v: Vec3): Vec3 {\n\t\treturn new Vec3(this.y*v.z - v.y*this.z, this.z*v.x - v.z*this.x, this.x*v.y - v.x*this.y);\n\t};\n\t\n\t/** Vector addition\n\t    * @param v the vector to be added\n\t    * @return addition result */\n\tadd(v: Vec3): Vec3 {\n\t\treturn new Vec3(this.x+v.x, this.y+v.y, this.z+v.z); \n\t};\n\t\n\t/** Normalize the vector */\n\tnormalize(): void{\n\t    let d = 1./this.length();\n\t    this.x *= d; \n\t    this.y *= d; \n\t    this.z *= d;\n\t};\n\t\n\t/** Return normalized vector */\n\tnorm(): Vec3 {\n\t\tlet d = 1./this.length();\n\t\treturn new Vec3(this.x*d, this.y*d, this.z*d);\n\t};\n\t  \n\t/** Vector length\n    @return the length of the vector. */\n\tlength(): number{ \n\t\treturn Math.sqrt(this.lengthSquared()); \n\t};\n\n  /** Squared vector length\n      @return the squared length of the vector. */\n\tlengthSquared(): number{ \n\t\treturn this.x*this.x + this.y*this.y + this.z*this.z; \n  \t};\n  \t\n  \t/** Computes the dot product of the this vector and {@code v1}.\n     * @param v1 another vector\n     * @return dot product */\n  \tdot(v1: Vec3): number {\n\t   return this.x*v1.x + this.y*v1.y + this.z*v1.z; \n   \t};\n   \t\n   \t/** Vector subtraction\n     * @param v the vector to be subtracted\n     * @return subtraction result */\n   \tsub(v: Vec3): Vec3 {\n   \t\treturn new Vec3(this.x-v.x, this.y-v.y, this.z-v.z); \n   \t};\n\t\n   \n   \t\n   \t/** Angle between two vectors.\n    @param v1 another vector\n    @return the angle in radians between this vector and {@code v1};\n      constrained to the range [0,PI]. */\n   \tangle(v1: Vec3): number { \n   \t\treturn Hploc.atan2(this.cross(v1).length(), this.dot(v1)); \n   \t}\n   \t\n   \t/** Invert the signs of all components */\n    flip(): void { \n    \tthis.x *= -1.0;\n    \tthis.y *= -1.0;\n    \tthis.z *= -1.0;\n    }\n   \t\n   \tstatic pointing2Vec3(pointing: Pointing): Vec3{\n   \t\tlet sth = Hploc.sin(pointing.theta);\n   \t    let x = sth * Hploc.cos(pointing.phi);\n   \t    let y = sth * Hploc.sin(pointing.phi);\n   \t    let z = Hploc.cos(pointing.theta);\n   \t    return new Vec3(x, y, z);\n   \t    \n   \t};\n} \n\n","\nimport {Vec3} from './Vec3.js';\n\n\nexport class CircleFinder{\n\t\n\tcenter;\t// Vec3\n\tcosrad;\t// double\n\t\n/**\n * @param point: Vec3\n */\n\tconstructor(point){\n\t\t\n\t\tlet np = point.length;\n\t    //HealpixUtils.check(np>=2,\"too few points\");\n\t    if (!(np>=2)){\n\t    \tconsole.log(\"too few points\");\n\t    \treturn;\n\t    }\n\t    this.center = point[0].add(point[1]); \n\t    this.center.normalize();\n\t    this.cosrad = point[0].dot(this.center);\n\t    for (let i=2; i<np; ++i){\n\t    \tif (point[i].dot(this.center)<this.cosrad){ // point outside the current circle\n\t\t        this.getCircle(point,i);\t\n\t    \t}\n\t    }\n\t      \n\t};\n\t\n\t/**\n\t * @parm point: Vec3\n\t * @param q: int\n\t */\n\tgetCircle (point, q){\n\t\tthis.center = point[0].add(point[q]); \n\t\tthis.center.normalize();\n\t\tthis.cosrad = point[0].dot(this.center);\n\t\tfor (let i=1; i<q; ++i){\n\t\t\tif (point[i].dot(this.center)<this.cosrad){ // point outside the current circle\n\t\t\t\tthis.getCircle2(point,i,q);\n\t\t\t}\n\t\t}\n    };\n\t\n\t/**\n\t * @parm point: Vec3\n\t * @param q1: int\n\t * @param q2: int\n\t */\n\tgetCircle2 (point, q1, q2){\n\t\tthis.center = point[q1].add(point[q2]); \n\t\tthis.center.normalize();\n\t\tthis.cosrad = point[q1].dot(this.center);\n\t\tfor (let i=0; i<q1; ++i){\n\t\t\tif (point[i].dot(this.center)<this.cosrad){// point outside the current circle\n\t        \n\t\t\t\tthis.center=(point[q1].sub(point[i])).cross(point[q2].sub(point[i]));\n\t\t\t\tthis.center.normalize();\n\t\t\t\tthis.cosrad=point[i].dot(this.center);\n\t\t\t\tif (this.cosrad<0){ \n\t\t\t\t\tthis.center.flip(); \n\t\t\t\t\tthis.cosrad=-this.cosrad; \n\t\t\t\t}\n\t        }\n\t\t}\n    };\n    \n    getCenter() { \n    \treturn new Vec3(this.center.x, this.center.y, this.center.z); \n    }\n    \n    getCosrad() { \n    \treturn this.cosrad; \n    };\n\t\n}\n\n","/**\n * Partial porting to Javascript of Fxyf.java from Healpix3.30\n */\n\nimport {Hploc} from './Hploc.js';\nimport {Vec3} from './Vec3.js';\n\nexport class Fxyf{ \n\t\n\tfx: number;\n\tfy: number;\n\tface: number;\n\tjrll: Uint8Array;\n\tjpll: Uint8Array;\n\thalfpi: number;\n\n\tconstructor(x: number, y: number, f: number){\n\t\tthis.fx=x; \n\t\tthis.fy=y; \n\t\tthis.face=f; \n\t\t// coordinate of the lowest corner of each face\n\t\tthis.jrll = new Uint8Array([ 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4 ]);\n\t\tthis.jpll = new Uint8Array([ 1, 3, 5, 7, 0, 2, 4, 6, 1, 3, 5, 7 ]);\n\t\tthis.halfpi = Math.PI/2.;\n\t}\n\n\ttoHploc(): Hploc{\t\n\t\tlet loc = new Hploc();\n\t\t\n\t\tlet jr = this.jrll[this.face] - this.fx - this.fy;\n\t\t\n\t\tlet nr: number;\n\t\n\t\tif (jr<1){\n\t\t\t  nr = jr;\n\t\t\t  let tmp = nr*nr/3.;\n\t\t\t  loc.z = 1 - tmp;\n\t\t\t  if (loc.z > 0.99) { \n\t\t\t\t  loc.sth = Math.sqrt(tmp*(2.0-tmp)); \n\t\t\t\t  loc.have_sth = true; \n\t\t\t  }\n\t\t}else if (jr > 3){\n\t\t\t  nr = 4 - jr;\n\t\t\t  let tmp = nr*nr/3.;\n\t\t\t  loc.z = tmp - 1;\n\t\t\t  if (loc.z <- 0.99) { \n\t\t\t\t  loc.sth = Math.sqrt(tmp*(2.0-tmp)); \n\t\t\t\t  loc.have_sth = true; \n\t\t\t  }\n\t\t}else{\n\t\t\t  nr = 1;\n\t\t\t  loc.z = (2 - jr)*2.0/3.;\n\t\t}\n\t\n\t\tlet tmp = this.jpll[this.face]*nr+this.fx-this.fy;\n\t\tif (tmp < 0) {\n\t\t\ttmp += 8;\n\t\t}\n\t\tif (tmp >= 8) {\n\t\t\ttmp -= 8;\n\t\t}\n\t\tloc.phi = (nr<1e-15) ? 0 : (0.5*this.halfpi*tmp)/nr;\n\t\treturn loc;\n\t};\n\t\n\t\n\ttoVec3(): Vec3{ \n\t\treturn this.toHploc().toVec3(); \n\t};\n}\n\n\n","export class RangeSet{\n\t\n\tr: Int32Array;\n\tsz: number;\n\t/**\n\t * @param int cap: initial capacity\n\t */\n\tconstructor(cap?: number){\n\t\tif (cap<0) console.error(\"capacity must be positive\");\n\t    this.r = new Int32Array(cap<<1);\n\t    this.sz=0;\n\t};\n\t\n\t\n\t/** Append a single-value range to the object.\n    @param val value to append */\n\tappend (val: number): void { \n\t\tthis.append1(val,val+1); \n\t};\n\t\n\t\n\t /** Append a range to the object.\n    @param a first long in range\n    @param b one-after-last long in range */\n\tappend1 (a: number, b: number): void {\n\t\tif (a>=b) return;\n\t\tif ((this.sz>0) && (a<=this.r[this.sz-1])) {\n\t\t\tif (a<this.r[this.sz-2]) console.error(\"bad append operation\");\n\t\t\tif (b>this.r[this.sz-1]) this.r[this.sz-1]=b;\n\t\t\treturn;\n\t\t}\n\t\t// this.ensureCapacity(this.sz+2);\n\t\tlet cap = this.sz+2;\n\t\tif (this.r.length < cap) {\n\t\t\tlet newsize = Math.max( 2 * this.r.length,cap);\n\t\t\tlet rnew = new Int32Array(newsize);\n\t\t\trnew.set(this.r);\n\t\t\tthis.r = rnew;\n\t\t}\n\t\t\n\t\tthis.r[this.sz] = a;\n\t\tthis.r[this.sz+1] = b;\n\t\tthis.sz+=2;\n\t};\n\t\n\t/** Make sure the object can hold at least the given number of entries. \n\t * @param cap int\n\t * */\n  \tensureCapacity(cap: number): void { \n  \t\tif (this.r.length < cap) \n  \t\t\tthis.resize (Math.max( 2 * this.r.length,cap)); \n  \t};\n\t\n\t/**\n\t * @param newsize int\n\t */\n\tresize(newsize: number): void {\n\t\tif (newsize<this.sz)  console.error(\"requested array size too small\");\n\t\tif (newsize == this.r.length) return;\n\t\tlet rnew = new Int32Array(newsize);\n\t\tlet sliced = this.r.slice(0, this.sz + 1);\n//\t\tthis.arrayCopy(this.r, 0, rnew, 0, this.sz);\n\t\tthis.r = sliced;\n    };\n\t\n//\tarrayCopy(src, srcIndex, dest, destIndex, length) {\n//\t\tdest.splice(destIndex, length, ...src.slice(srcIndex, srcIndex + length));\n//\t};\n\n  \n  \n}\n\n","/**\n * Partial porting to Javascript of Xyf.java from Healpix3.30  \n */\nexport class Xyf{\n\n\tix: number;\n\tiy: number;\n\tface: number;\n\n\tconstructor(x: number, y: number, f: number){\n\t\tthis.ix = x;\n\t\tthis.iy = y;\n\t\tthis.face = f;\n\t}\n}\n\n\n","\"use strict\";\r\n\r\nimport { CircleFinder } from \"./CircleFinder.js\";\r\nimport { Constants } from \"./Constants.js\";\r\nimport { Fxyf } from \"./Fxyf.js\";\r\nimport { Hploc } from \"./Hploc.js\";\r\nimport { Pointing } from \"./Pointing.js\";\r\nimport { pstack } from \"./pstack.js\";\r\nimport { RangeSet } from \"./RangeSet.js\";\r\nimport { Vec3 } from \"./Vec3.js\";\r\nimport { Xyf } from \"./Xyf.js\";\r\nimport { Zphi } from \"./Zphi.js\";\r\n\r\n/**\r\n * Partial porting to Javascript of HealpixBase.java from Healpix3.30\r\n */\r\n\r\n// import Fxyf from './Fxyf.js';\r\n// import Hploc from './Hploc.js';\r\n// import Xyf from './Xyf.js';\r\n// import Vec3 from './Vec3.js';\r\n// import Pointing from './Pointing.js';\r\n// import CircleFinder from './CircleFinder.js';\r\n// import Zphi from './Zphi.js';\r\n// import pstack from './pstack.js';\r\n// import Constants from './Constants.js';\r\n// import RangeSet from './RangeSet.js';\r\n\r\n\r\nexport class Healpix {\r\n\r\n    order_max: number;\r\n    inv_halfpi: number;\r\n    twothird: number;\r\n    ns_max: number;\r\n    ctab: Uint16Array;\r\n    utab: Uint16Array;\r\n    xoffset: Int16Array;\r\n    yoffset: Int16Array;\r\n\r\n    jrll: Int16Array;\r\n    jpll: Int16Array;\r\n\r\n    facearray: Int16Array[];\r\n    swaparray: Int16Array[];\r\n    nside: number;\r\n    npface: number;\r\n    npix: number;\r\n    order: number;\r\n    nl2: number;\r\n    nl3: number;\r\n    nl4: number;\r\n    fact2: number;\r\n    fact1: number;\r\n    ncap: number; // pixel\r\n    bn: Healpix[];\r\n    mpr: number[];\r\n    cmpr: number[];\r\n    smpr: number[];\r\n\r\n    constructor(nside_in: number) {\r\n        this.order_max = 29;\r\n        this.inv_halfpi = 2.0 / Math.PI;\r\n        this.twothird = 2.0 / 3.;\r\n        // console.log(\"twothird \"+this.twothird);\r\n        // this.ns_max=1L<<order_max;\r\n        this.ns_max = Math.pow(2, this.order_max);\r\n        this.ctab = new Uint16Array([\r\n            0, 1, 256, 257, 2, 3, 258, 259, 512, 513, 768, 769, 514, 515, 770, 771, 4, 5, 260, 261, 6, 7, 262,\r\n            263, 516, 517, 772, 773, 518, 519, 774, 775, 1024, 1025, 1280, 1281, 1026, 1027, 1282, 1283,\r\n            1536, 1537, 1792, 1793, 1538, 1539, 1794, 1795, 1028, 1029, 1284, 1285, 1030, 1031, 1286,\r\n            1287, 1540, 1541, 1796, 1797, 1542, 1543, 1798, 1799, 8, 9, 264, 265, 10, 11, 266, 267, 520,\r\n            521, 776, 777, 522, 523, 778, 779, 12, 13, 268, 269, 14, 15, 270, 271, 524, 525, 780, 781, 526,\r\n            527, 782, 783, 1032, 1033, 1288, 1289, 1034, 1035, 1290, 1291, 1544, 1545, 1800, 1801, 1546,\r\n            1547, 1802, 1803, 1036, 1037, 1292, 1293, 1038, 1039, 1294, 1295, 1548, 1549, 1804, 1805,\r\n            1550, 1551, 1806, 1807, 2048, 2049, 2304, 2305, 2050, 2051, 2306, 2307, 2560, 2561, 2816,\r\n            2817, 2562, 2563, 2818, 2819, 2052, 2053, 2308, 2309, 2054, 2055, 2310, 2311, 2564, 2565,\r\n            2820, 2821, 2566, 2567, 2822, 2823, 3072, 3073, 3328, 3329, 3074, 3075, 3330, 3331, 3584,\r\n            3585, 3840, 3841, 3586, 3587, 3842, 3843, 3076, 3077, 3332, 3333, 3078, 3079, 3334, 3335,\r\n            3588, 3589, 3844, 3845, 3590, 3591, 3846, 3847, 2056, 2057, 2312, 2313, 2058, 2059, 2314,\r\n            2315, 2568, 2569, 2824, 2825, 2570, 2571, 2826, 2827, 2060, 2061, 2316, 2317, 2062, 2063,\r\n            2318, 2319, 2572, 2573, 2828, 2829, 2574, 2575, 2830, 2831, 3080, 3081, 3336, 3337, 3082,\r\n            3083, 3338, 3339, 3592, 3593, 3848, 3849, 3594, 3595, 3850, 3851, 3084, 3085, 3340, 3341,\r\n            3086, 3087, 3342, 3343, 3596, 3597, 3852, 3853, 3598, 3599, 3854, 3855]);\r\n        this.utab = new Uint16Array([0, 1, 4, 5, 16, 17, 20, 21, 64, 65, 68, 69, 80, 81, 84, 85, 256, 257, 260, 261, 272, 273, 276, 277,\r\n            320, 321, 324, 325, 336, 337, 340, 341, 1024, 1025, 1028, 1029, 1040, 1041, 1044, 1045, 1088,\r\n            1089, 1092, 1093, 1104, 1105, 1108, 1109, 1280, 1281, 1284, 1285, 1296, 1297, 1300, 1301,\r\n            1344, 1345, 1348, 1349, 1360, 1361, 1364, 1365, 4096, 4097, 4100, 4101, 4112, 4113, 4116,\r\n            4117, 4160, 4161, 4164, 4165, 4176, 4177, 4180, 4181, 4352, 4353, 4356, 4357, 4368, 4369,\r\n            4372, 4373, 4416, 4417, 4420, 4421, 4432, 4433, 4436, 4437, 5120, 5121, 5124, 5125, 5136,\r\n            5137, 5140, 5141, 5184, 5185, 5188, 5189, 5200, 5201, 5204, 5205, 5376, 5377, 5380, 5381,\r\n            5392, 5393, 5396, 5397, 5440, 5441, 5444, 5445, 5456, 5457, 5460, 5461, 16384, 16385, 16388,\r\n            16389, 16400, 16401, 16404, 16405, 16448, 16449, 16452, 16453, 16464, 16465, 16468, 16469,\r\n            16640, 16641, 16644, 16645, 16656, 16657, 16660, 16661, 16704, 16705, 16708, 16709, 16720,\r\n            16721, 16724, 16725, 17408, 17409, 17412, 17413, 17424, 17425, 17428, 17429, 17472, 17473,\r\n            17476, 17477, 17488, 17489, 17492, 17493, 17664, 17665, 17668, 17669, 17680, 17681, 17684,\r\n            17685, 17728, 17729, 17732, 17733, 17744, 17745, 17748, 17749, 20480, 20481, 20484, 20485,\r\n            20496, 20497, 20500, 20501, 20544, 20545, 20548, 20549, 20560, 20561, 20564, 20565, 20736,\r\n            20737, 20740, 20741, 20752, 20753, 20756, 20757, 20800, 20801, 20804, 20805, 20816, 20817,\r\n            20820, 20821, 21504, 21505, 21508, 21509, 21520, 21521, 21524, 21525, 21568, 21569, 21572,\r\n            21573, 21584, 21585, 21588, 21589, 21760, 21761, 21764, 21765, 21776, 21777, 21780, 21781,\r\n            21824, 21825, 21828, 21829, 21840, 21841, 21844, 21845]);\r\n\r\n        this.jrll = new Int16Array([2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4]);\r\n        this.jpll = new Int16Array([1, 3, 5, 7, 0, 2, 4, 6, 1, 3, 5, 7]);\r\n\r\n        this.xoffset = new Int16Array([-1, -1, 0, 1, 1, 1, 0, -1]);\r\n        this.yoffset = new Int16Array([0, 1, 1, 1, 0, -1, -1, -1]);\r\n        this.facearray = [\r\n            new Int16Array([8, 9, 10, 11, -1, -1, -1, -1, 10, 11, 8, 9]),// S\r\n            new Int16Array([5, 6, 7, 4, 8, 9, 10, 11, 9, 10, 11, 8]),// SE\r\n            new Int16Array([-1, -1, -1, -1, 5, 6, 7, 4, -1, -1, -1, -1]),// E\r\n            new Int16Array([4, 5, 6, 7, 11, 8, 9, 10, 11, 8, 9, 10]), // SW\r\n            new Int16Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]),// center\r\n            new Int16Array([1, 2, 3, 0, 0, 1, 2, 3, 5, 6, 7, 4]),// NE\r\n            new Int16Array([-1, -1, -1, -1, 7, 4, 5, 6, -1, -1, -1, -1]),// W\r\n            new Int16Array([3, 0, 1, 2, 3, 0, 1, 2, 4, 5, 6, 7]),// NW\r\n            new Int16Array([2, 3, 0, 1, -1, -1, -1, -1, 0, 1, 2, 3])// N\r\n        ];\r\n        // questo forse deve essere un UInt8Array. Viene usato da neighbours\r\n        this.swaparray = [\r\n            new Int16Array([0, 0, 3]),// S\r\n            new Int16Array([0, 0, 6]),// SE\r\n            new Int16Array([0, 0, 0]),// E\r\n            new Int16Array([0, 0, 5]), // SW\r\n            new Int16Array([0, 0, 0]),// center\r\n            new Int16Array([5, 0, 0]),// NE\r\n            new Int16Array([0, 0, 0]),// W\r\n            new Int16Array([6, 0, 0]),// NW\r\n            new Int16Array([3, 0, 0])// N\r\n        ];\r\n        if (nside_in <= this.ns_max && nside_in > 0) {\r\n            this.nside = nside_in;\r\n            this.npface = this.nside * this.nside;\r\n            this.npix = 12 * this.npface;\r\n            this.order = this.nside2order(this.nside);\r\n            this.nl2 = 2 * this.nside;\r\n            this.nl3 = 3 * this.nside;\r\n            this.nl4 = 4 * this.nside;\r\n            this.fact2 = 4.0 / this.npix;\r\n            this.fact1 = (this.nside << 1) * this.fact2;\r\n            this.ncap = 2 * this.nside * (this.nside - 1); // pixels in each polar cap\r\n            // console.log(\"order: \"+this.order);\r\n            // console.log(\"nside: \"+this.nside);\r\n\r\n        }\r\n\r\n        this.bn = [];\r\n        this.mpr = [];\r\n        this.cmpr = [];\r\n        this.smpr = [];\r\n\r\n        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT\r\n        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT\r\n        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT\r\n        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT\r\n        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT\r\n        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT\r\n        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT\r\n        // Uncaught RangeError: Maximum call stack size exceeded\r\n        // MOVED TO computeBn()\r\n        //        for (let i=0; i <= this.order_max; ++i) {\r\n        //        \tthis.bn[i]=new Healpix(1<<i);\r\n        //        \tthis.mpr[i]=bn[i].maxPixrad();\r\n        //        \tthis.cmpr[i]=Math.cos(mpr[i]);\r\n        //        \tthis.smpr[i]=Math.sin(mpr[i]);\r\n        //        }\r\n\r\n    }\r\n\r\n\r\n    computeBn(): void {\r\n        for (let i = 0; i <= this.order_max; ++i) {\r\n            this.bn[i] = new Healpix(1 << i);\r\n            this.mpr[i] = this.bn[i].maxPixrad();\r\n            this.cmpr[i] = Hploc.cos(this.mpr[i]);\r\n            this.smpr[i] = Hploc.sin(this.mpr[i]);\r\n        }\r\n    }\r\n\r\n    getNPix(): number {\r\n        return this.npix;\r\n    };\r\n\r\n\r\n    getBoundaries(pix: number): Vec3[] {\r\n        let points = new Array<Vec3>();\r\n        let xyf = this.nest2xyf(pix);\r\n\r\n        let dc = 0.5 / this.nside;\r\n        let xc = (xyf.ix + 0.5) / this.nside;\r\n        let yc = (xyf.iy + 0.5) / this.nside;\r\n\r\n        points[0] = new Fxyf(xc + dc, yc + dc, xyf.face).toVec3();\r\n        points[1] = new Fxyf(xc - dc, yc + dc, xyf.face).toVec3();\r\n        points[2] = new Fxyf(xc - dc, yc - dc, xyf.face).toVec3();\r\n        points[3] = new Fxyf(xc + dc, yc - dc, xyf.face).toVec3();\r\n        return points;\r\n    };\r\n\r\n\r\n    /** Returns a set of points along the boundary of the given pixel.\r\n     * Step 1 gives 4 points on the corners. The first point corresponds\r\n     * to the northernmost corner, the subsequent points follow the pixel\r\n     * boundary through west, south and east corners.\r\n     *\r\n     * @param pix pixel index number\r\n     * @param step the number of returned points is 4*step\r\n     * @return {@link Vec3} for each point\r\n     */\r\n    getBoundariesWithStep(pix: number, step: number): Vec3[] {\r\n        // var points = new Array(); \r\n        let points = new Array<Vec3>();\r\n        let xyf = this.nest2xyf(pix);\r\n        let dc = 0.5 / this.nside;\r\n        let xc = (xyf.ix + 0.5) / this.nside;\r\n        let yc = (xyf.iy + 0.5) / this.nside;\r\n        let d = 1.0 / (this.nside * step);\r\n\r\n        for (let i = 0; i < step; i++) {\r\n            points[i] = new Fxyf(xc + dc - i * d, yc + dc, xyf.face).toVec3();\r\n            points[i + step] = new Fxyf(xc - dc, yc + dc - i * d, xyf.face).toVec3();\r\n            points[i + 2 * step] = new Fxyf(xc - dc + i * d, yc - dc, xyf.face).toVec3();\r\n            points[i + 3 * step] = new Fxyf(xc + dc, yc - dc + i * d, xyf.face).toVec3();\r\n        }\r\n        return points;\r\n    };\r\n\r\n    getPointsForXyfNoStep(x: number, y: number, face: number): Vec3[] {\r\n        // let nside = Math.pow(2, this.order);\r\n        let points = new Array<Vec3>();\r\n        let xyf = new Xyf(x, y, face);\r\n\r\n        let dc = 0.5 / this.nside;\r\n        let xc = (xyf.ix + 0.5) / this.nside;\r\n        let yc = (xyf.iy + 0.5) / this.nside;\r\n\r\n        points[0] = new Fxyf(xc + dc, yc + dc, xyf.face).toVec3();\r\n        points[1] = new Fxyf(xc - dc, yc + dc, xyf.face).toVec3();\r\n        points[2] = new Fxyf(xc - dc, yc - dc, xyf.face).toVec3();\r\n        points[3] = new Fxyf(xc + dc, yc - dc, xyf.face).toVec3();\r\n\r\n        return points;\r\n\r\n    }\r\n\r\n    getPointsForXyf(x: number, y: number, step: number, face: number): Vec3[] {\r\n        let nside = step * Math.pow(2, this.order);\r\n        let points = new Array<Vec3>();\r\n        let xyf = new Xyf(x, y, face);\r\n\r\n        let dc = 0.5 / nside;\r\n        let xc = (xyf.ix + 0.5) / nside;\r\n        let yc = (xyf.iy + 0.5) / nside;\r\n\r\n        points[0] = new Fxyf(xc + dc, yc + dc, xyf.face).toVec3();\r\n        points[1] = new Fxyf(xc - dc, yc + dc, xyf.face).toVec3();\r\n        points[2] = new Fxyf(xc - dc, yc - dc, xyf.face).toVec3();\r\n        points[3] = new Fxyf(xc + dc, yc - dc, xyf.face).toVec3();\r\n\r\n        return points;\r\n    }\r\n\r\n    /** Returns the neighboring pixels of ipix.\r\n    This method works in both RING and NEST schemes, but is\r\n    considerably faster in the NEST scheme.\r\n    @param ipix the requested pixel number.\r\n    @return array with indices of the neighboring pixels.\r\n      The returned array contains (in this order)\r\n      the pixel numbers of the SW, W, NW, N, NE, E, SE and S neighbor\r\n      of ipix. If a neighbor does not exist (this can only happen\r\n      for the W, N, E and S neighbors), its entry is set to -1. */\r\n    neighbours(ipix: number): Int32Array {\r\n        let result = new Int32Array(8);\r\n        let xyf = this.nest2xyf(ipix);\r\n        let ix = xyf.ix;\r\n        let iy = xyf.iy;\r\n        let face_num = xyf.face;\r\n\r\n        var nsm1 = this.nside - 1;\r\n        if ((ix > 0) && (ix < nsm1) && (iy > 0) && (iy < nsm1)) {\r\n            let fpix = Math.floor(face_num << (2 * this.order));\r\n            let px0 = this.spread_bits(ix);\r\n            let py0 = this.spread_bits(iy) << 1;\r\n            let pxp = this.spread_bits(ix + 1);\r\n            let pyp = this.spread_bits(iy + 1) << 1;\r\n            let pxm = this.spread_bits(ix - 1);\r\n            let pym = this.spread_bits(iy - 1) << 1;\r\n\r\n            result[0] = fpix + pxm + py0;\r\n            result[1] = fpix + pxm + pyp;\r\n            result[2] = fpix + px0 + pyp;\r\n            result[3] = fpix + pxp + pyp;\r\n            result[4] = fpix + pxp + py0;\r\n            result[5] = fpix + pxp + pym;\r\n            result[6] = fpix + px0 + pym;\r\n            result[7] = fpix + pxm + pym;\r\n        } else {\r\n            for (let i = 0; i < 8; ++i) {\r\n                let x = ix + this.xoffset[i];\r\n                let y = iy + this.yoffset[i];\r\n                let nbnum = 4;\r\n                if (x < 0) {\r\n                    x += this.nside;\r\n                    nbnum -= 1;\r\n                } else if (x >= this.nside) {\r\n                    x -= this.nside;\r\n                    nbnum += 1;\r\n                }\r\n                if (y < 0) {\r\n                    y += this.nside;\r\n                    nbnum -= 3;\r\n                } else if (y >= this.nside) {\r\n                    y -= this.nside;\r\n                    nbnum += 3;\r\n                }\r\n\r\n                let f = this.facearray[nbnum][face_num];\r\n\r\n                if (f >= 0) {\r\n                    let bits = this.swaparray[nbnum][face_num >>> 2];\r\n                    if ((bits & 1) > 0) {\r\n                        x = Math.floor(this.nside - x - 1);\r\n                    }\r\n                    if ((bits & 2) > 0) {\r\n                        y = Math.floor(this.nside - y - 1);\r\n                    }\r\n                    if ((bits & 4) > 0) {\r\n                        let tint = x;\r\n                        x = y;\r\n                        y = tint;\r\n                    }\r\n                    result[i] = this.xyf2nest(x, y, f);\r\n                } else {\r\n                    result[i] = -1;\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n\r\n\r\n    nside2order(nside: number): number {\r\n        return ((nside & (nside - 1)) != 0) ? -1 : Math.log2(nside);\r\n    };\r\n\r\n    nest2xyf(ipix: number): Xyf {\r\n        let pix = Math.floor(ipix & (this.npface - 1));\r\n        let xyf = new Xyf(this.compress_bits(pix), this.compress_bits(pix >> 1),\r\n            Math.floor((ipix >> (2 * this.order))));\r\n        return xyf;\r\n    };\r\n\r\n\r\n    xyf2nest(ix: number, iy: number, face_num: number): number {\r\n\r\n        return Math.floor(face_num << (2 * this.order))\r\n            + this.spread_bits(ix) + (this.spread_bits(iy) << 1);\r\n    };\r\n\r\n    loc2pix(hploc: Hploc): number {\r\n        let z = hploc.z;\r\n        let phi = hploc.phi;\r\n\r\n        let za = Math.abs(z);\r\n        let tt = this.fmodulo((phi * this.inv_halfpi), 4.0);// in [0,4)\r\n        let pixNo: number;\r\n        if (za <= this.twothird) {// Equatorial region\r\n            let temp1 = this.nside * (0.5 + tt);\r\n            let temp2 = this.nside * (z * 0.75);\r\n            let jp = Math.floor(temp1 - temp2); // index of ascending edge line\r\n            let jm = Math.floor(temp1 + temp2); // index of descending edge line\r\n            let ifp = Math.floor(jp >>> this.order);  // in {0,4}\r\n            let ifm = Math.floor(jm >>> this.order);\r\n            let face_num = Math.floor((ifp == ifm) ? (ifp | 4) : ((ifp < ifm) ? ifp : (ifm + 8)));\r\n            let ix = Math.floor(jm & (this.nside - 1));\r\n            let iy = Math.floor(this.nside - (jp & (this.nside - 1)) - 1);\r\n            pixNo = this.xyf2nest(ix, iy, face_num);\r\n        } else { // polar region, za > 2/3\r\n            let ntt = Math.min(3, Math.floor(tt));\r\n            let tp = tt - ntt;\r\n            let tmp = ((za < 0.99) || (!hploc.have_sth)) ?\r\n                this.nside * Math.sqrt(3 * (1 - za)) :\r\n                this.nside * hploc.sth / Math.sqrt((1.0 + za) / 3.);\r\n            let jp = Math.floor(tp * tmp); // increasing edge line index\r\n            let jm = Math.floor((1.0 - tp) * tmp); // decreasing edge line index\r\n            if (jp >= this.nside) {\r\n                jp = this.nside - 1; // for points too close to the boundary\r\n            }\r\n            if (jm >= this.nside) {\r\n                jm = this.nside - 1;\r\n            }\r\n\r\n            if (z >= 0) {\r\n                pixNo = this.xyf2nest(Math.floor(this.nside - jm - 1), Math.floor(this.nside - jp - 1), ntt);\r\n            } else {\r\n                pixNo = this.xyf2nest(Math.floor(jp), Math.floor(jm), ntt + 8);\r\n            }\r\n\r\n        }\r\n        return pixNo;\r\n    };\r\n\r\n\r\n    /** Returns the normalized 3-vector corresponding to the center of the\r\n    supplied pixel.\r\n    @param pix long the requested pixel number.\r\n    @return the pixel's center coordinates. */\r\n    pix2vec(pix: number): Vec3 {\r\n        return this.pix2loc(pix).toVec3();\r\n    };\r\n\r\n    /** Returns the Zphi corresponding to the center of the supplied pixel.\r\n     @param pix the requested pixel number.\r\n     @return the pixel's center coordinates. */\r\n    pix2zphi(pix: number): Zphi {\r\n        return this.pix2loc(pix).toZphi();\r\n    }\r\n\r\n\r\n    /**\r\n     * @param pix long\r\n     * @return Hploc\r\n     */\r\n    pix2loc(pix: number): Hploc {\r\n        let loc = new Hploc(undefined);\r\n\r\n\r\n        let xyf = this.nest2xyf(pix);\r\n\r\n        let jr = ((this.jrll[xyf.face]) << this.order) - xyf.ix - xyf.iy - 1;\r\n\r\n        let nr;\r\n        if (jr < this.nside) {\r\n            nr = jr;\r\n            let tmp = (nr * nr) * this.fact2;\r\n            loc.z = 1 - tmp;\r\n            if (loc.z > 0.99) {\r\n                loc.sth = Math.sqrt(tmp * (2. - tmp));\r\n                loc.have_sth = true;\r\n            }\r\n        } else if (jr > this.nl3) {\r\n            nr = this.nl4 - jr;\r\n            let tmp = (nr * nr) * this.fact2;\r\n            loc.z = tmp - 1;\r\n            if (loc.z < -0.99) {\r\n                loc.sth = Math.sqrt(tmp * (2. - tmp));\r\n                loc.have_sth = true;\r\n            }\r\n        } else {\r\n            nr = this.nside;\r\n            loc.z = (this.nl2 - jr) * this.fact1;\r\n        }\r\n\r\n        let tmp = (this.jpll[xyf.face]) * nr + xyf.ix - xyf.iy;\r\n        //      \tassert(tmp<8*nr); // must not happen\r\n        if (tmp < 0) {\r\n            tmp += 8 * nr;\r\n        }\r\n        loc.phi = (nr == this.nside) ? 0.75 * Constants.halfpi * tmp * this.fact1 : (0.5 * Constants.halfpi * tmp) / nr;\r\n        // loc.setPhi((nr == this.nside) ? 0.75 * Constants.halfpi * tmp * this.fact1 : (0.5 * Constants.halfpi * tmp)/nr);\r\n        return loc;\r\n    };\r\n\r\n    vec2ang(v: Vec3) {\r\n        const { z, a } = this.vec2za(v[0], v[1], v[2])\r\n        return { theta: Math.acos(z), phi: a }\r\n    }\r\n\r\n    vec2za(X: number, Y: number, z: number) {\r\n        const r2 = X * X + Y * Y\r\n        if (r2 == 0)\r\n            return { z: z < 0 ? -1 : 1, a: 0 }\r\n        else {\r\n            const PI2 = Math.PI/2\r\n            const a = (Math.atan2(Y, X) + PI2) % PI2\r\n            z /= Math.sqrt(z * z + r2)\r\n            return { z, a }\r\n        }\r\n    }\r\n\r\n\r\n    ang2pix(ptg: Pointing, mirror?: boolean) {\r\n        return this.loc2pix(new Hploc(ptg));\r\n    };\r\n\r\n    fmodulo(v1: number, v2: number): number {\r\n        if (v1 >= 0) {\r\n            return (v1 < v2) ? v1 : v1 % v2;\r\n        }\r\n        var tmp = v1 % v2 + v2;\r\n        return (tmp === v2) ? 0.0 : tmp;\r\n    };\r\n\r\n    compress_bits(v: number): number {\r\n        var raw = Math.floor((v & 0x5555)) | Math.floor(((v & 0x55550000) >>> 15));\r\n        var compressed = this.ctab[raw & 0xff] | (this.ctab[raw >>> 8] << 4);\r\n        return compressed;\r\n    };\r\n\r\n\r\n    spread_bits(v: number): number {\r\n        return Math.floor(this.utab[v & 0xff]) | Math.floor((this.utab[(v >>> 8) & 0xff] << 16))\r\n            | Math.floor((this.utab[(v >>> 16) & 0xff] << 32)) | Math.floor((this.utab[(v >>> 24) & 0xff] << 48));\r\n    };\r\n\r\n\r\n    /**\r\n     * Returns a range set of pixels that overlap with the convex polygon\r\n     * defined by the {@code vertex} array.\r\n     * <p>\r\n     * This method is more efficient in the RING scheme.\r\n     * <p>\r\n     * This method may return some pixels which don't overlap with the polygon\r\n     * at all. The higher {@code fact} is chosen, the fewer false positives are\r\n     * returned, at the cost of increased run time.\r\n     * \r\n     * @param vertex\r\n     *            an array containing the vertices of the requested convex\r\n     *            polygon.\r\n     * @param fact\r\n     *            The overlapping test will be done at the resolution\r\n     *            {@code fact*nside}. For NESTED ordering, {@code fact} must be\r\n     *            a power of 2, else it can be any positive integer. A typical\r\n     *            choice would be 4.\r\n     * @return the requested set of pixel number ranges\r\n     */\r\n    queryPolygonInclusive(vertex: Pointing[], fact: number): RangeSet {\r\n        let inclusive = (fact != 0);\r\n        let nv = vertex.length;\r\n        //        let ncirc = inclusive ? nv+1 : nv;\r\n\r\n        if (!(nv >= 3)) {\r\n            console.log(\"not enough vertices in polygon\");\r\n            return;\r\n        }\r\n        let vv = new Array<Vec3>();\r\n        for (let i = 0; i < nv; ++i) {\r\n            vv[i] = Vec3.pointing2Vec3(vertex[i]);\r\n        }\r\n\r\n\r\n        let normal = new Array<Vec3>();\r\n        let flip = 0;\r\n        let index = 0;\r\n        let back = false;\r\n\r\n        while (index < vv.length) {\r\n\r\n            let first = vv[index];\r\n            let medium = null;\r\n            let last = null;\r\n\r\n            if (index == vv.length - 1) {\r\n                last = vv[1];\r\n                medium = vv[0];\r\n            } else if (index == vv.length - 2) {\r\n                last = vv[0];\r\n                medium = vv[index + 1];\r\n            } else {\r\n                medium = vv[index + 1];\r\n                last = vv[index + 2];\r\n            }\r\n\r\n            normal[index] = first.cross(medium).norm();\r\n            let hnd = normal[index].dot(last);\r\n\r\n            if (index == 0) {\r\n                flip = (hnd < 0.) ? -1 : 1;\r\n\r\n                let tmp = new Pointing(first); // TODO not used\r\n                back = false;\r\n            } else {\r\n                let flipThnd = flip * hnd;\r\n                if (flipThnd < 0) {\r\n                    let tmp = new Pointing(medium);\r\n                    vv.splice(index + 1, 1);\r\n                    normal.splice(index, 1);\r\n                    back = true;\r\n                    index -= 1;\r\n                    continue;\r\n                } else {\r\n                    let tmp = new Pointing(first);\r\n                    back = false;\r\n                }\r\n            }\r\n\r\n\r\n            normal[index].scale(flip);\r\n            index += 1;\r\n\r\n        }\r\n        nv = vv.length;\r\n        let ncirc = inclusive ? nv + 1 : nv;\r\n\r\n        let rad = new Array(ncirc);\r\n        rad = rad.fill(Constants.halfpi);\r\n        //        rad = rad.fill(1.5707963267948966);\r\n        //        let p = \"1.5707963267948966\";\r\n        //        rad = rad.fill(parseFloat(p));\r\n\r\n        if (inclusive) {\r\n            let cf = new CircleFinder(vv);\r\n            normal[nv] = cf.getCenter();\r\n            rad[nv] = Hploc.acos(cf.getCosrad());\r\n        }\r\n        return this.queryMultiDisc(normal, rad, fact);\r\n\r\n    };\r\n\r\n    /**\r\n     * For NEST schema only\r\n     * \r\n     * @param normal:\r\n     *            Vec3[]\r\n     * @param rad:\r\n     *            Float32Array\r\n     * @param fact:\r\n     *            The overlapping test will be done at the resolution\r\n     *            {@code fact*nside}. For NESTED ordering, {@code fact} must be\r\n     *            a power of 2, else it can be any positive integer. A typical\r\n     *            choice would be 4.\r\n     * @return RangeSet the requested set of pixel number ranges\r\n     */\r\n    queryMultiDisc(norm: Vec3[], rad: number[], fact: number): RangeSet {\r\n        this.computeBn();\r\n\r\n        let inclusive = (fact != 0);\r\n        let nv = norm.length;\r\n        // HealpixUtils.check(nv==rad.lengt0,\"inconsistent input arrays\");\r\n        if (!(nv == rad.length)) {\r\n            console.error(\"inconsistent input arrays\");\r\n            return;\r\n        }\r\n\r\n        let res = new RangeSet(4 << 1);\r\n        // Removed code for Scheme.RING\r\n        let oplus = 0;\r\n        if (inclusive) {\r\n            if (!(Math.pow(2, this.order_max - this.order) >= fact)) {\r\n                console.error(\"invalid oversampling factor\");\r\n            }\r\n            if (!((fact & (fact - 1)) == 0)) {\r\n                console.error(\"oversampling factor must be a power of 2\");\r\n            }\r\n\r\n            oplus = this.ilog2(fact);\r\n\r\n        }\r\n        let omax = this.order + oplus; // the order up to which we test\r\n\r\n        // TODO: ignore all disks with radius>=pi\r\n\r\n        //        let crlimit = new Float32Array[omax+1][nv][3];\r\n        let crlimit = new Array(omax + 1);\r\n        let o: number;\r\n        let i: number;\r\n        for (o = 0; o <= omax; ++o) { // prepare data at the required orders\r\n            crlimit[o] = new Array(nv);\r\n            let dr = this.bn[o].maxPixrad(); // safety distance\r\n            for (i = 0; i < nv; ++i) {\r\n\r\n                crlimit[o][i] = new Float64Array(3);\r\n                crlimit[o][i][0] = (rad[i] + dr > Math.PI) ? -1 : Hploc.cos(rad[i] + dr);\r\n                crlimit[o][i][1] = (o == 0) ? Hploc.cos(rad[i]) : crlimit[0][i][1];\r\n                crlimit[o][i][2] = (rad[i] - dr < 0.) ? 1. : Hploc.cos(rad[i] - dr);\r\n            }\r\n        }\r\n\r\n        let stk = new pstack(12 + 3 * omax);\r\n        for (let i = 0; i < 12; i++) { // insert the 12 base pixels in reverse\r\n            // order\r\n            stk.push(11 - i, 0);\r\n        }\r\n\r\n        while (stk.size() > 0) { // as long as there are pixels on the stack\r\n            // pop current pixel number and order from the stack\r\n            let pix = stk.ptop();\r\n            let o = stk.otop();\r\n            stk.pop();\r\n\r\n            let pv = this.bn[o].pix2vec(pix);\r\n\r\n            let zone = 3;\r\n            for (let i = 0; (i < nv) && (zone > 0); ++i) {\r\n                let crad = pv.dot(norm[i]);\r\n                for (let iz = 0; iz < zone; ++iz) {\r\n                    if (crad < crlimit[o][i][iz]) {\r\n                        zone = iz;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (zone > 0) {\r\n                this.check_pixel(o, omax, zone, res, pix, stk, inclusive);\r\n            }\r\n        }\r\n        return res;\r\n    };\r\n\r\n    /** Integer base 2 logarithm.\r\n    @param arg\r\n    @return the largest integer {@code n} that fulfills {@code 2^n<=arg}.\r\n    For negative arguments and zero, 0 is returned. */\r\n    ilog2(arg: number): number {\r\n        let max = Math.max(arg, 1);\r\n        return 31 - Math.clz32(max);\r\n    };\r\n\r\n    /** Computes the cosine of the angular distance between two z, phi positions\r\n      on the unit sphere. */\r\n    cosdist_zphi(z1: number, phi1: number, z2: number, phi2: number): number {\r\n        return z1 * z2 + Hploc.cos(phi1 - phi2) * Math.sqrt((1.0 - z1 * z1) * (1.0 - z2 * z2));\r\n    }\r\n\r\n    /**\r\n     * @param int o\r\n     * @param int omax\r\n     * @param int zone\r\n     * @param RangeSet pixset\r\n     * @param long pix\r\n     * @param pstack stk\r\n     * @param boolean inclusive\r\n     */\r\n    check_pixel(o: number, omax: number, zone: number, pixset: RangeSet, pix: number, stk: pstack, inclusive: boolean) {\r\n\r\n        if (zone == 0) return;\r\n\r\n        if (o < this.order) {\r\n            if (zone >= 3) {// output all subpixels\r\n                let sdist = 2 * (this.order - o); // the \"bit-shift distance\" between map orders\r\n                pixset.append1(pix << sdist, ((pix + 1) << sdist));\r\n            } else {// (zone>=1)\r\n                for (let i = 0; i < 4; ++i) {\r\n                    stk.push(4 * pix + 3 - i, o + 1); // add children\r\n                }\r\n            }\r\n        } else if (o > this.order) {// this implies that inclusive==true\r\n\r\n            if (zone >= 2) {// pixel center in shape\r\n                pixset.append(pix >>> (2 * (o - this.order))); // output the parent pixel at order\r\n                stk.popToMark(); // unwind the stack\r\n            } else {// (zone>=1): pixel center in safety range\r\n                if (o < omax) {// check sublevels\r\n                    for (let i = 0; i < 4; ++i) { // add children in reverse order\r\n                        stk.push(4 * pix + 3 - i, o + 1); // add children\r\n                    }\r\n                } else {// at resolution limit\r\n                    pixset.append(pix >>> (2 * (o - this.order)));// output the parent pixel at order\r\n                    stk.popToMark(); // unwind the stack\r\n                }\r\n            }\r\n        } else {// o==order\r\n            if (zone >= 2) {\r\n                pixset.append(pix);\r\n            } else if (inclusive) {// and (zone>=1)\r\n                if (this.order < omax) {// check sublevels\r\n                    stk.mark(); // remember current stack position\r\n                    for (let i = 0; i < 4; ++i) { // add children in reverse order\r\n                        stk.push(4 * pix + 3 - i, o + 1); // add children\r\n                    }\r\n                } else {// at resolution limit\r\n                    pixset.append(pix); // output the pixel\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Returns the maximum angular distance between a pixel center and its\r\n    corners.\r\n    @return maximum angular distance between a pixel center and its\r\n      corners. */\r\n    maxPixrad() {\r\n\r\n        let zphia = new Zphi(2. / 3., Math.PI / this.nl4);\r\n        let xyz1 = this.convertZphi2xyz(zphia);\r\n\r\n        let va = new Vec3(xyz1[0], xyz1[1], xyz1[2]);\r\n        let t1 = 1. - 1. / this.nside;\r\n        t1 *= t1;\r\n\r\n\r\n        let zphib = new Zphi(1 - t1 / 3, 0);\r\n        let xyz2 = this.convertZphi2xyz(zphib);\r\n\r\n        let vb = new Vec3(xyz2[0], xyz2[1], xyz2[2]);\r\n        return va.angle(vb);\r\n    };\r\n\r\n\r\n\r\n    /**\r\n     * this is a workaround replacing the Vec3(Zphi) constructor.\r\n     */\r\n    convertZphi2xyz(zphi: Zphi): [number, number, number] {\r\n\r\n        let sth = Math.sqrt((1.0 - zphi.z) * (1.0 + zphi.z));\r\n        let x = sth * Hploc.cos(zphi.phi);\r\n        let y = sth * Hploc.sin(zphi.phi);\r\n        let z = zphi.z;\r\n        return [x, y, z];\r\n\r\n    };\r\n\r\n    /** Returns a range set of pixels which overlap with a given disk. <p>\r\n      This method is more efficient in the RING scheme. <p>\r\n      This method may return some pixels which don't overlap with\r\n      the polygon at all. The higher {@code fact} is chosen, the fewer false\r\n      positives are returned, at the cost of increased run time.\r\n      @param ptg the angular coordinates of the disk center\r\n      @param radius the radius (in radians) of the disk\r\n      @param fact The overlapping test will be done at the resolution\r\n        {@code fact*nside}. For NESTED ordering, {@code fact} must be a power\r\n        of 2, else it can be any positive integer. A typical choice would be 4.\r\n      @return the requested set of pixel number ranges  */\r\n    queryDiscInclusive(ptg: Pointing, radius: number, fact: number): RangeSet {\r\n        this.computeBn();\r\n        let inclusive = (fact != 0);\r\n        let pixset = new RangeSet();\r\n\r\n        if (radius >= Math.PI) {// disk covers the whole sphere\r\n            pixset.append1(0, this.npix); return pixset;\r\n        }\r\n\r\n        let oplus = 0;\r\n        if (inclusive) {\r\n            // HealpixUtils.check ((1L<<order_max)>=fact,\"invalid oversampling factor\");\r\n\r\n            if (!((fact & (fact - 1)) == 0)) {\r\n                console.error(\"oversampling factor must be a power of 2\");\r\n            }\r\n            oplus = this.ilog2(fact);\r\n        }\r\n\r\n        let omax = Math.min(this.order_max, this.order + oplus); // the order up to which we test\r\n        let vptg = Vec3.pointing2Vec3(ptg);\r\n        let crpdr = new Array(omax + 1);\r\n        let crmdr = new Array(omax + 1);\r\n\r\n        let cosrad = Hploc.cos(radius);\r\n        let sinrad = Hploc.sin(radius);\r\n        for (let o = 0; o <= omax; o++) {// prepare data at the required orders\r\n\r\n            let dr = this.mpr[o]; // safety distance\r\n            let cdr = this.cmpr[o];\r\n            let sdr = this.smpr[o];\r\n            crpdr[o] = (radius + dr > Math.PI) ? -1. : cosrad * cdr - sinrad * sdr;\r\n            crmdr[o] = (radius - dr < 0.) ? 1. : cosrad * cdr + sinrad * sdr;\r\n        }\r\n\r\n        let stk = new pstack(12 + 3 * omax);\r\n        for (let i = 0; i < 12; i++) {// insert the 12 base pixels in reverse order\r\n            stk.push(11 - i, 0);\r\n        }\r\n\r\n        while (stk.size() > 0) {// as long as there are pixels on the stack\r\n            // pop current pixel number and order from the stack\r\n            let pix = stk.ptop();\r\n            let curro = stk.otop();\r\n            stk.pop();\r\n\r\n            let pos = this.bn[curro].pix2zphi(pix);\r\n            // cosine of angular distance between pixel center and disk center\r\n            let cangdist = this.cosdist_zphi(vptg.z, ptg.phi, pos.z, pos.phi);\r\n\r\n            if (cangdist > crpdr[curro]) {\r\n                let zone = (cangdist < cosrad) ? 1 : ((cangdist <= crmdr[curro]) ? 2 : 3);\r\n                this.check_pixel(curro, omax, zone, pixset, pix, stk, inclusive);\r\n            }\r\n        }\r\n        return pixset;\r\n    }\r\n\r\n}\r\n\r\n// export default Healpix;\r\n// export {\r\n//     Hploc,\r\n//     Vec3,\r\n//     Pointing\r\n// };"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","Constants","halfpi","inv_halfpi","Math","PI","twopi","inv_twopi","pstack","constructor","sz","this","p","Array","Int32Array","s","m","push","p_","o_","pop","popToMark","size","mark","otop","ptop","Zphi","z_","phi_","z","phi","Hploc","ptg","PI4_A","PI4_B","PI4_C","M_1_PI","sth","have_sth","cos","theta","_phi","abs","sin","setZ","setSth","toVec3","st","sqrt","Vec3","toZphi","static","d","u","q","floor","x","sincoshelper","mulsign","atan2k","y","copySign","magnitude","sign","t","atanhelper","r","isinf","isnan","NaN","Pointing","vec3","mirror","in_theta","in_phi","atan2","in_x","in_y","in_z","getX","getY","getZ","scale","n","cross","v","add","normalize","length","norm","lengthSquared","dot","v1","sub","angle","flip","pointing","CircleFinder","point","np","center","cosrad","i","getCircle","console","log","getCircle2","q1","q2","getCenter","getCosrad","Fxyf","f","fx","fy","face","jrll","Uint8Array","jpll","toHploc","nr","loc","jr","tmp","RangeSet","cap","error","append","val","append1","a","b","newsize","max","rnew","set","ensureCapacity","resize","sliced","slice","Xyf","ix","iy","Healpix","nside_in","order_max","twothird","ns_max","pow","ctab","Uint16Array","utab","Int16Array","xoffset","yoffset","facearray","swaparray","nside","npface","npix","order","nside2order","nl2","nl3","nl4","fact2","fact1","ncap","bn","mpr","cmpr","smpr","computeBn","maxPixrad","getNPix","getBoundaries","pix","points","xyf","nest2xyf","dc","xc","yc","getBoundariesWithStep","step","getPointsForXyfNoStep","getPointsForXyf","neighbours","ipix","result","face_num","nsm1","fpix","px0","spread_bits","py0","pxp","pyp","pxm","pym","nbnum","bits","tint","xyf2nest","log2","compress_bits","loc2pix","hploc","pixNo","za","tt","fmodulo","temp1","temp2","jp","jm","ifp","ifm","ntt","min","tp","pix2vec","pix2loc","pix2zphi","undefined","vec2ang","vec2za","acos","X","Y","r2","PI2","ang2pix","v2","raw","queryPolygonInclusive","vertex","fact","inclusive","nv","vv","pointing2Vec3","normal","index","back","first","medium","last","hnd","splice","rad","fill","cf","queryMultiDisc","res","oplus","ilog2","omax","crlimit","dr","Float64Array","stk","pv","zone","crad","iz","check_pixel","arg","clz32","cosdist_zphi","z1","phi1","z2","phi2","pixset","sdist","zphia","xyz1","convertZphi2xyz","va","t1","zphib","xyz2","vb","zphi","queryDiscInclusive","radius","vptg","crpdr","crmdr","sinrad","cdr","sdr","curro","pos","cangdist"],"sourceRoot":""}